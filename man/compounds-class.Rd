% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compounds.R
\docType{class}
\name{compounds-class}
\alias{compounds-class}
\alias{compounds}
\alias{compoundsConsensus-class}
\alias{compoundsConsensus}
\alias{compoundTable,compounds-method}
\alias{compoundTable}
\alias{algorithm,compounds-method}
\alias{groupNames,compounds-method}
\alias{length,compounds-method}
\alias{show,compounds-method}
\alias{[,compounds,ANY,missing,missing-method}
\alias{[[,compounds,ANY,missing-method}
\alias{$,compounds-method}
\alias{as.data.table,compounds-method}
\alias{identifiers,compounds-method}
\alias{identifiers}
\alias{filter,compounds-method}
\alias{addFormulaScoring,compounds-method}
\alias{addFormulaScoring}
\alias{getMCS,compounds-method}
\alias{plotStructure,compounds-method}
\alias{plotScores,compounds-method}
\alias{plotScores}
\alias{plotSpec,compounds-method}
\alias{consensus,compounds-method}
\title{Compound lists class}
\usage{
\S4method{compoundTable}{compounds}(obj)

\S4method{algorithm}{compounds}(obj)

\S4method{groupNames}{compounds}(obj)

\S4method{length}{compounds}(x)

\S4method{show}{compounds}(object)

\S4method{[}{compounds,ANY,missing,missing}(x, i, j, ..., drop = TRUE)

\S4method{[[}{compounds,ANY,missing}(x, i, j)

\S4method{$}{compounds}(x, name)

\S4method{as.data.table}{compounds}(x, fGroups = NULL,
  fragments = FALSE)

\S4method{identifiers}{compounds}(compounds)

\S4method{filter}{compounds}(obj, minExplainedPeaks = NULL,
  minScore = NULL, minFragScore = NULL, minFormulaScore = NULL,
  scoreLimits = NULL, elements = NULL, fragElements = NULL,
  topMost = NULL)

\S4method{addFormulaScoring}{compounds}(compounds, formulas,
  updateScore = FALSE, formulaScoreWeight = 1)

\S4method{getMCS}{compounds}(obj, index, groupName)

\S4method{plotStructure}{compounds}(obj, index, groupName, width = 500,
  height = 500, useGGPlot2 = FALSE)

\S4method{plotScores}{compounds}(obj, index, groupName,
  normalizeScores = "max", excludeNormScores = NULL,
  useGGPlot2 = FALSE)

\S4method{plotSpec}{compounds}(obj, index, groupName, MSPeakLists,
  formulas = NULL, plotStruct = TRUE, useGGPlot2 = FALSE)

\S4method{consensus}{compounds}(obj, ..., compThreshold = 0,
  minMaxNormalization = TRUE, mergeScoresFunc = sum)
}
\arguments{
\item{obj, object, x, compounds}{The \code{compound} object.}

\item{i}{A numeric or character value which is used to select feature groups by
their index or name, respectively (for the order/names see \code{groupNames()}).\cr\cr For \code{[}: Can also be logical to perform logical selection
(similar to regular vectors). If missing all feature groups are selected.\cr\cr For \code{[[}: should be a skalar value.}

\item{\dots}{\code{compounds} objects that should be used to generate the
consensus.}

\item{drop, j}{ignored.}

\item{name}{The feature group name (partially matched).}

\item{fGroups}{The \code{\link{featureGroups}} object that was used to
generate this object. If not \code{NULL} it is used to add feature group
information (retention and \emph{m/z} values).}

\item{fragments}{If \code{TRUE} then information on annotated fragments will
be included.}

\item{minExplainedPeaks, minScore, minFragScore, minFormulaScore}{Minimal number
of explained peaks, overall score, in-silico fragmentation score and
formula score, respectively. Set to \code{NULL} to ignore. The
\code{scoreLimits} argument allows for more advanced score filtering.}

\item{scoreLimits}{Filter results by their scores. Should be a named
\code{list} that contains two-sized numeric vectors with the
minimum/maximum value of a score (use \code{-Inf}/\code{Inf} for no
limits). The names of each element should follow the values returned by
\code{\link{compoundScorings}()$name}. For instance,
\code{scoreLimits=list(numberPatents=c(10, Inf))} specifies that
\code{numberPatents} should be at least \samp{10}. For more details of
scorings see \code{\link{compoundScorings}}. Note that a result without a
specified scoring is never removed. Set to \code{NULL} to skip this filter.}

\item{elements}{Only retain candidate formulae (neutral form) that match a
given elemental restriction. The format of \code{elements} is a
\code{character} string with elements that should be present where each
element is followed by a valid amount or a range thereof. If no number is
specified then \samp{1} is assumed. For instance,
\code{elements="C1-10H2-20O0-2P"}, specifies that \samp{1-10}, \samp{2-20},
\samp{0-2} and \samp{1} carbon, hydrogen, oxygen and phosphorus atoms
should be present, respectively. When \code{length(elements)>1} formulas
are tested to follow at least one of the given elemental restrictions. For
instance, \code{elements=c("P", "S")} specifies that either one phosphorus
or one sulphur atom should be present. Set to \code{NULL} to ignore this
filter.}

\item{fragElements}{Specifies
elemental restrictions for fragment
formulae (charged form). Candidates are retained if at least one of the fragment
formulae follow the given restrictions. See \code{elements} for the used
format.}

\item{topMost}{Only keep a maximum of \code{topMost} candidates with highest
score. Set to \code{NULL} to ignore.}

\item{formulas}{The \code{\link{formulas}} object that should be
used for scoring/annotation. For \code{plotSpec}: set to \code{NULL} to
ignore.}

\item{updateScore}{If set to \code{TRUE} then the \code{score} column is
updated by adding the normalized \option{formulaScore} (weighted by
\option{formulaScoreWeight}). Currently, this \strong{only} makes sense for
\command{MetFrag} results!}

\item{formulaScoreWeight}{Weight used to update scoring (see
\code{updateScore} parameter).}

\item{index}{The numeric index of the candidate structure. Multiple indices
(\emph{i.e.} vector with length >=2) may be specified for
\code{plotStructure} and are mandatory for \code{getMCS}. Alternatively,
\samp{-1} may be specified to these methods to select all candidates. When
multiple indices are specified for \code{plotStructure}, their maximum
common substructure will be drawn.}

\item{groupName}{The name of the feature group to which the candidate
belongs.}

\item{width, height}{The dimensions (in pixels) of the raster image that
should be plotted.}

\item{useGGPlot2}{If \code{TRUE} then \pkg{\link{ggplot2}} is used for
plotting, otherwise base plot used. For \code{plotSpec}, \code{ggplot2}
allows nicely repelled text for annotation. However, base plot is generally
faster.}

\item{normalizeScores}{A \code{character} that specifies how normalization of
compound scorings occurs. Either \code{"none"} (no normalization),
\code{"max"} (normalize to max value) or \code{"minmax"} (perform min-max
normalization). Note that normalization of negative scores (e.g. output by
SIRIUS) is always performed as min-max.}

\item{excludeNormScores}{A \code{character} vector specifying any compound
scoring names that should \emph{not} be normalized. Set to \code{NULL} to
normalize all scorings. Note that whether any normalization occurs is set
by the \code{excludeNormScores} argument.}

\item{MSPeakLists}{The \code{\link{MSPeakLists}} object that was used to
generate the candidate}

\item{plotStruct}{If \code{TRUE} then the candidate structure is drawn in the
spectrum.}

\item{compThreshold}{Minimal fraction (0-1) that a candidate must be present
within all given \code{compounds} objects.}

\item{minMaxNormalization}{Set to \code{TRUE} to apply min-max normalization
of (merged) scoring columns. \code{FALSE} will apply normalization to the
maximum value. Scorings with negative values will always be min-max
normalized.}

\item{mergeScoresFunc}{Function used to calculate the total score for all
(merged) score columns.}
}
\value{
\code{plotSpec} and \code{plotStructure} will return a
  \code{\link[=ggplot2]{ggplot object}} if \code{useGGPlot2} is \code{TRUE}.

\code{compoundTable} returns a \code{list} containing for each feature
  group a \code{\link{data.table}} with an overview of all candidate
  compounds and other data such as candidate scoring, matched MS/MS
  fragments, etc.

\code{filter} returns a filtered \code{compounds} object.

\code{addFormulaScoring} returns a \code{compounds} object updated
  with formula scoring.

\code{getMCS} returns an \CRANpkg{rcdk} molecule object
  (\code{IAtomContainer}).

\code{consensus} returns a \code{compounds} object that is produced
  by merging multiple specified \code{compounds} objects.
}
\description{
Contains data of generated chemical compounds for given feature groups.
}
\details{
\code{compounds} objects are obtained from
\link[=compound-generation]{compound generators}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{compoundTable}: Accessor method to obtain generated compounds.

\item \code{algorithm}: Accessor method for the algorithm (a character
string) used to generate compounds.

\item \code{groupNames}: returns a \code{character} vector with the names of the
feature groups for which data is present in this object.

\item \code{length}: Obtain total number of candidate compounds.

\item \code{show}: Show summary information for this object.

\item \code{[}: Subset on feature groups.

\item \code{[[}: Extract a compound table for a feature group.

\item \code{$}: Extract a compound table for a feature group.

\item \code{as.data.table}: Returns all MS peak list data in a table.

\item \code{identifiers}: Returns a list containing for each feature group a
character vector with database identifiers for all candidate compounds. The
list is named by feature group names, and is typically used with the
\code{identifiers} option of \code{\link{generateCompoundsMetfrag}}.

\item \code{filter}: Provides rule based filtering for generated compounds.
Useful to eliminate unlikely candidates and speed up further processing.

\item \code{addFormulaScoring}: Provides compound scoring data that is based on the
presence of candidate formulae being present in a given
\code{\link{formulas}} object. Matched precursor formulae yield one
point, whereas matched MS/MS fragments yield 0.5 point each.

\item \code{getMCS}: Calculates the maximum common substructure (MCS)
for two or more candidate structures for a feature group. This method uses
the \code{\link{get.mcs}} function from \CRANpkg{rcdk}.

\item \code{plotStructure}: Plots a structure of a candidate compound using the
\CRANpkg{rcdk} package. If multiple candidates are specified (\emph{i.e.}
by specifying a \code{vector} for \code{index}) then the maximum common
substructure (MCS) of the selected candidates is drawn.

\item \code{plotScores}: Plots a barplot with scoring of a candidate compound.

\item \code{plotSpec}: Plots an annotated spectrum for a given candidate
compound of a feature group.

\item \code{consensus}: Generates a consensus from multiple \code{compounds}
objects. The compound results will be merged and optionally compounds will
be filtered by their occurrence throughout the specified \code{compounds}
objects.
}}

\section{Slots}{

\describe{
\item{\code{compounds}}{Lists of all generated compounds. Use the \code{compounds}
method for access.}

\item{\code{algorithm}}{The algorithm that was used for generation of compounds. Use
the \code{algorithm} method for access.}
}}

\section{S4 class hierarchy}{
 \itemize{   \item{\code{\link{workflowStep}}}   \itemize{     \item{\strong{\code{\link{compounds}}}}     \itemize{       \item{\code{\link{compoundsConsensus}}}       \item{\code{\link{compoundsMF}}}     }   } }
}

\references{
\addCitations{rcdk}{1}
}
