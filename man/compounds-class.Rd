% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compounds.R
\docType{class}
\name{compounds-class}
\alias{compounds-class}
\alias{compounds}
\alias{compoundTable,compounds-method}
\alias{compoundTable}
\alias{algorithm,compounds-method}
\alias{groupNames,compounds-method}
\alias{length,compounds-method}
\alias{show,compounds-method}
\alias{[,compounds,ANY,missing,missing-method}
\alias{identifiers,compounds-method}
\alias{identifiers}
\alias{filter,compounds-method}
\alias{filterBy,compounds-method}
\alias{addFormulaScoring,compounds-method}
\alias{addFormulaScoring}
\alias{getMCS,compounds-method}
\alias{plotStructure,compounds-method}
\alias{plotScores,compounds-method}
\alias{plotScores}
\alias{plotSpec,compounds-method}
\alias{consensus,compounds-method}
\title{Compound lists class}
\usage{
\S4method{compoundTable}{compounds}(obj)

\S4method{algorithm}{compounds}(obj)

\S4method{groupNames}{compounds}(obj)

\S4method{length}{compounds}(x)

\S4method{show}{compounds}(object)

\S4method{[}{compounds,ANY,missing,missing}(x, i, j, ..., drop = TRUE)

\S4method{identifiers}{compounds}(compounds)

\S4method{filter}{compounds}(obj, minExplainedPeaks = NULL,
  minScore = NULL, minFragScore = NULL, minFormulaScore = NULL,
  topMost = NULL)

\S4method{filterBy}{compounds}(obj, fGroups, negate)

\S4method{addFormulaScoring}{compounds}(compounds, formConsensus,
  updateScore = FALSE, formulaScoreWeight = 1)

\S4method{getMCS}{compounds}(obj, index, groupName)

\S4method{plotStructure}{compounds}(obj, index, groupName, width = 500,
  height = 500, useGGPlot2 = FALSE)

\S4method{plotScores}{compounds}(obj, index, groupName,
  normalizeScores = TRUE, useGGPlot2 = FALSE)

\S4method{plotSpec}{compounds}(obj, index, groupName, MSPeakLists,
  formConsensus = NULL, plotStruct = TRUE, useGGPlot2 = FALSE)

\S4method{consensus}{compounds}(obj, ..., compThreshold = 0,
  mergeScoresFunc = sum)
}
\arguments{
\item{obj, object, x, compounds}{The \code{compound} object.}

\item{i}{Either a numeric, character or logical \code{vector} that is used to select feature groups by their index, name and logical selection, respectively (for the order/names see \code{groupNames()}). If missing all feature groups are selected.}

\item{j}{ignored.}

\item{\dots}{\code{compounds} objects that should be used to generate the
consensus.}

\item{drop}{ignored.}

\item{minExplainedPeaks, minScore, minFragScore, minFormulaScore}{Minimal number
of explained peaks, overall score, in-silico fragmentation score and
formula score, respectively. Set to \code{NULL} to ignore.}

\item{topMost}{Only keep a maximum of \code{topMost} candidates with highest
score. Set to \code{NULL} to ignore.}

\item{fGroups}{A \code{\link{featureGroups}} object which should be filtered.}

\item{negate}{If set to \code{TRUE} then the filter is applied in opposite
manner.}

\item{formConsensus}{The \code{\link{formulaConsensus}} object that should be
used for scoring/annotation. For \code{plotSpec}: set to \code{NULL} to
ignore.}

\item{updateScore}{If set to \code{TRUE} then the \code{score} column is
updated by adding the normalized \option{formulaScore} (weighted by
\option{formulaScoreWeight}). Currently, this \strong{only} makes sense for
\command{MetFrag} results!}

\item{formulaScoreWeight}{Weight used to update scoring (see
\code{updateScore} parameter).}

\item{index}{The numeric index of the candidate structure. Multiple indices
(\emph{i.e.} vector with length >=2) may be specified for
\code{plotStructure} and are mandatory for \code{getMCS}. Alternatively,
\samp{-1} may be specified to these methods to select all candidates. When
multiple indices are specified for \code{plotStructure}, their maximum
common substructure will be drawn.}

\item{groupName}{The name of the feature group to which the candidate
belongs.}

\item{width, height}{The dimensions (in pixels) of the raster image that
should be plotted.}

\item{useGGPlot2}{If \code{TRUE} then \pkg{\link{ggplot2}} is used for
plotting, otherwise base plot used. For \code{plotSpec}, \code{ggplot2}
allows nicely repelled text for annotation. However, base plot is generally
faster.}

\item{normalizeScores}{Normalize scores to maximum values.}

\item{MSPeakLists}{The \code{\link{MSPeakLists}} object that was used to
generate the candidate}

\item{plotStruct}{If \code{TRUE} then the candidate structure is drawn in the
spectrum.}

\item{compThreshold}{Minimal fraction (0-1) that a candidate must be present
within all given \code{compounds} objects.}

\item{mergeScoresFunc}{Function used to calculate the total score for all
(merged) score columns.}
}
\value{
\code{plotSpec} and \code{plotStructure} will return a
  \code{\link[=ggplot2]{ggplot object}} if \code{useGGPlot2} is \code{TRUE}.

\code{compoundTable} returns a \code{list} containing for each feature
  group a \code{\link{data.table}} with an overview of all candidate
  compounds and other data such as candidate scoring, matched MS/MS
  fragments, etc.

\code{filter} returns a filtered \code{compounds} object.

\code{filterBy} returns a filtered \code{\link{featureGroups}}
  object.

\code{addFormulaScoring} returns a \code{compounds} object updated
  with formula scoring.

\code{getMCS} returns an \CRANpkg{rcdk} molecule object
  (\code{IAtomContainer}).

\code{consensus} returns a \code{compounds} object that is produced
  by merging multiple specified \code{compounds} objects.
}
\description{
Contains data of generated chemical compounds for given feature groups.
}
\details{
\code{compounds} objects are obtained from
\link[=compound-generation]{compound generators}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{compoundTable}: Accessor method to obtain generated compounds.

\item \code{algorithm}: Accessor method for the algorithm (a character
string) used to generate compounds.

\item \code{groupNames}: returns a \code{character} vector with the names of the
feature groups from which data is present in this object.

\item \code{length}: Obtain total number of candidate compounds.

\item \code{show}: Show summary information for this object.

\item \code{[}: Operator to subset on feature groups .

\item \code{identifiers}: Returns a list containing for each feature group a
character vector with database identifiers for all candidate compounds. The
list is named by feature group names, and is typically used with the
\code{identifiers} option of \code{\link{generateCompoundsMetfrag}}.

\item \code{filter}: Provides rule based filtering for generated compounds.
Useful to eliminate unlikely candidates and speed up further processing.

\item \code{filterBy}: Only keep feature groups in a given
\code{\link{featureGroups}} object that are also present in the specified
\code{compounds} object.

\item \code{addFormulaScoring}: Provides compound scoring data that is based on the
presence of candidate formulae being present in a given
\code{\link{formulaConsensus}} object. Matched precursor formulae yield one
point, whereas matched MS/MS fragments yield 0.5 point each.

\item \code{getMCS}: Calculates the maximum common substructure (MCS)
for two or more candidate structures for a feature group. This method uses
the \code{\link{get.mcs}} function from \CRANpkg{rcdk}.

\item \code{plotStructure}: Plots a structure of a candidate compound using the
\CRANpkg{rcdk} package. If multiple candidates are specified (\emph{i.e.}
by specifying a \code{vector} for \code{index}) then the maximum common
substructure (MCS) of the selected candidates is drawn.

\item \code{plotScores}: Plots a barplot with scoring of a candidate compound.

\item \code{plotSpec}: Plots an annotated spectrum for a given candidate
compound of a feature group.

\item \code{consensus}: Generates a consensus from multiple \code{compounds}
objects. The compound results will be merged and optionally compounds will
be filtered by their occurrence throughout the specified \code{compounds}
objects.
}}

\section{Slots}{

\describe{
\item{\code{compounds}}{Lists of all generated compounds. Use the \code{compounds}
method for access.}

\item{\code{algorithm}}{The algorithm that was used for generation of compounds. Use
the \code{algorithm} method for access.}
}}

\references{
\addCitations{rcdk}{1}
}
