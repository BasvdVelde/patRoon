# Processing workflow data

- overlap/unique methods somewhere?

The previous chapter mainly discussed how to create workflow data. This chapter will discuss how to _use_ the data.

## Inspecting results

- add also non-workflow classes? (e.g. compclust->groupNames)

Several generic functions exist that can be used to inspect data that is stored in a particular object (e.g. features, compounds etc):

Generic                                             | Classes                       | Remarks
--------------------------------------------------- | ----------------------------- | ------------------------------------------
`length()`                                          | All                           | Returns the length of the object (e.g. number of features, compounds etc)
`groupNames()`                                      | All                           | Returns all the unique identitifiers (or names) of the feature groups for which this object contains results.
`names()`                                           | `featureGroups`, `components` | Returns names of the feature groups (similar to `groupNames()`) or components
`show()`                                            | All                           | Prints general information.
`"[["` / `"$"` operators                            | All                           | Extract general information, see below.
`as.data.table()` / `as.data.frame()`               | All                           | Convert data to a `data.table` or `data.frame`, see below.
`analysisInfo()`, `analyses()`, `replicateGroups()` | `features`, `featureGroups`   | Returns the [analysis information](#anaInfo), analyses or replicate groups for which this object contains data.
`groupInfo()`                                       | `featureGroups`               | Returns feature group information (_m/z_ and retention time values).
`componentInfo()`                                   | `components`                  | Returns information for all components.
`annotatedPeakList()`                               | `formulas`, `compounds`       | Returns a table with annotated mass peaks (see below).

The common `R` extraction operators `"[["`, `"$"` can be used to obtain data for a particular feature groups, analysis etc:

```{r extrOp,eval=FALSE}
# Feature table
fList[["analysis-1"]] # index by analysis name
fList[[1]] # or numeric index

# Feature group intensities
fGroups[["M109_R116_56"]]
fGroups$M109_R116_56 # as above
fGroups[[1, "M109_R116_56"]] # only first analysis

# obtains list with MS and MS/MS peak lists
mslists[["M109_R116_56"]] # group averaged data
mslists[["analysis-1", "M109_R116_56"]] # feature data

# get all formula candidates for a feature (group)
formulas[["M109_R116_56"]] # group averaged data
formulas[[1, "M109_R116_56"]] # feature data (if available, i.e. calculateFeatures=TRUE)

# get all compound candidates for a feature group
compounds[["M109_R116_56"]]

# get a table with information of a component
components[["CMP1"]]
components[["CMP1", 1]] # only for first feature group in component
```

A more sophisticated way to obtain data from a workflow object is to use `as.data.table()` or `as.data.frame()`. These functions will convert _all_ information within the object to a table (`data.table` or `data.frame`) and allow various options to add extra information. An advantage is that this common data format can be used with many other functions within `R`. The output is in a [tidy format](https://r4ds.had.co.nz/tidy-data.html).

> **_NOTE_** If you are not familiar with `data.table` and want to know more see [data.table]. Briefly, this is a more efficient and largely compatible alternative to the regular `data.frame`.

> **_NOTE_** The `as.data.frame()` methods defined in `patRoon` simply convert the results from `as.data.table()`, hence, both functions are equal in their usage and are defined for the same object classes.

Some typical examples are shown below.

```{r asDT,eval=FALSE}
# obtain table with all features
as.data.table(fList)
as.data.frame(fList) # ditto, but in classic data.frame format

# Returns group info and intensity values for each feature group
as.data.table(fGroups)
as.data.table(fGroups, average = TRUE) # average intensities for replicates
as.data.table(fGroups, features) # also include feature information

# Returns all peak lists for each feature group
as.data.table(mslists)
as.data.table(mslists, averaged = FALSE) # ditto, but for each feature
as.data.table(mslists, fGroups = fGroups) # add feature group information

# Returns all formula candidates for each feature group with scoring
# information, neutral loss etc
as.data.table(formulas)
# include carbon and hydrogen elemental counts: useful to construct van Krevelen plots
as.data.table(formulas, countElements = c("C", "H"))
# report only top precursor and fragment formula. This yields in one row per feature group.
as.data.table(formulas, maxFormulas = 1, maxFragFormulas = 1)
# add various information for organic matter characterization (common elemental
# counts/ratios, classifications etc)
as.data.table(formulas, OM = TRUE)

# Returns all compound candidates for each feature group with scoring and other metadata
as.data.table(compounds)
as.data.table(compounds, fGroups = fGroups) # add feature group informaion
as.data.table(compounds, fragments) # include information of all annotated fragments

# Returns table with all components (including feature group info, annotations etc)
as.data.table(components)
```

Finally, the `annotatedPeakList()` function is useful to inspect annotation results for a formula or compound candidate:

```{r annPList,eval=FALSE}
# formula annotation for for a formula candidate of feature group M109_R116_56
annotatedPeakList(compounds, precursor = "C6H9N2", groupName = "M109_R116_56",
                  MSPeakLists = mslists)
# only include annotated mass peaks
annotatedPeakList(compounds, index = 1, groupName = "M109_R116_56",
                  MSPeakLists = mslists, onlyAnnotated = TRUE)

# compound annotation for first candidate of feature group M109_R116_56
annotatedPeakList(compounds, index = 1, groupName = "M109_R116_56",
                  MSPeakLists = mslists)
# include formula annotations
annotatedPeakList(compounds, index = 1, groupName = "M109_R116_56",
                  MSPeakLists = mslists, formulas = formulas)
```

## Filtering

During a non-target workflow it is not uncommon that some kind of data-cleanup is necessary. Datasets are often highly complex, which makes separating data of interest from the rest highly important. Furthermore, general cleanup typically improves the quality of the dataset, for instance by removing low scoring annotation results or features that are unlikely to be 'correct' (e.g. noise or present in blanks). For this reason `patRoon` supports _many_ different filters that easily clean data produced during the workflow in a highly customizable way.

All major workflow objects (e.g. `featureGroups`, `compounds`, `components` etc.) support filtering operations by the `filter()` generic. This function takes the object to be filtered as first argument and any remaining arguments describe the desired filter options. The `filter()` generic function then returns the modified object back. Some examples are shown below.

```{r filtGen,eval=FALSE}
# remove low intensity (<500) features
features <- filter(features, absMinIntensity = 500)

# remove features with intensities lower than 5 times the blank
fGroups <- filter(fGroups, blankThreshold = 5)

# only retain compounds with >1 explained MS/MS peaks
compounds <- filter(compounds, minExplainedPeaks = 1)
```

The following sections will provide a more detailed overview of available data filters.

### Features

There are many filters available for feature data:

Filter                                     | Classes                     | Remarks
------------------------------------------ | --------------------------- | ---------------------------------------------------------
`absMinIntensity`, `relMinIntensity`       | `features`, `featureGroups` | Minimum intensity
`preAbsMinIntensity`, `preRelMinIntensity` | `featureGroups`             | Minimum intensity prior to other filtering (see below)
`retentionRange`, `mzRange`, `mzDefectRange`, `chromWidthRange` | `features`, `featureGroups` | Filter by feature properties
`absMinAnalyses`, `relMinAnalyses`         | `featureGroups`             | Minimum feature abundance in all analyses
`absMinReplicates`, `relMinReplicates`     | `featureGroups`             | Minimum feature abundance in different replicates
`absMinFeatures`, `relMinFeatures`         | `featureGroups`             | Only keep analyses with at least this amount of features 
`absMinReplicateAbundance`, `relMinReplicateAbundance` | `featureGroups` | Minimum feature abundance in a replicate group
`maxReplicateIntRSD`                       | `featureGroups`             | Maximum relative standard deviation of feature intensities in a replicate group.
`blankThreshold`                           | `featureGroups`             | Minimum intensity factor above blank intensity
`rGroups`                                  | `featureGroups`             | Only keep (features of) these replicate groups

Application of filters to feature data is important for (environmental) non-target analysis. Especially blank and replicate filters (i.e. `blankThreshold` and `absMinReplicateAbundance`/`relMinReplicateAbundance`) are important filters and are highly recommended to always apply for cleaning up your dataset.

All filters are available for feature group data, whereas only a subset is available for feature objects. The main reason is that other filters need grouping of features between analyses. Regardless, in `patRoon` filtering feature data is less important, and typically only needed when the number of features are extremely large and direct grouping is undesired.

From the table above you can notice that many filters concern both _absolute_ and _relative_ data (i.e. as prefixed with `abs` and `rel`). When a relative filter is used the value is scaled between _0_ and _1_. For instance:

```{r filtFeatRel,eval=FALSE}
# remove features not present in at least half of the analyses within a replicate group
fGroups <- filter(fGroups, relMinReplicateAbundance = 0.5)
```

An advantage of relative filters is that you will not have to worry about the data size involved. For instance, in the above example the filter always takes half of the number of analyses within a replicate group, even when replicate groups have different number of analyses.

Note that multiple filters can be specified at once. Especially for feature group data the order of filtering may impact the final results, this is explained further in the reference manual (i.e. ``?`feature-filtering` ``).

Some examples are shown below.

```{r filtFeat,eval=FALSE}
# filter features prior to grouping: remove any features eluting before first 2 minutes
fList <- filter(fList, retentionRange = c(120, Inf))

# common filters for feature groups
fGroups <- filter(fGroups,
                  absMinIntensity = 500, # remove features <500 intensity
                  relMinReplicateAbundance = 1, # features should be in all analysis of replicate groups
                  maxReplicateIntRSD = 0.75, # remove features with intensity RSD in replicates >75%
                  blankThreshold = 5, # remove features <5x intensity of (average) blank intensity
                  removeBlanks = TRUE) # remove blank analyses from object afterwards

# filter by feature properties
fGroups <- filter(mzDefectRange = c(0.8, 0.9),
                  chromWidthRange = c(6, 120))

# remove features not present in at least 3 analyses
fGroups <- filter(fGroups, absMinAnalyses = 3)

# remove features not present in at least 20% of all replicate groups
fGroups <- filter(fGroups, relMinReplicates = 0.2)

# only keep data present in replicate groups "repl1" and "repl2"
# all other features and analyses will be removed
fGroups <- filter(fGroups, rGroups = c("repl1", "repl2"))
```


### Annotation

- MSPeakLists: retain precursor

There are various filters available for handling annotation data:

Filter                                        | Classes                        | Remarks
--------------------------------------------- | ------------------------------ | -------------------------------------------------
`absMSIntThr`, `absMSMSIntThr`, `relMSIntThr`, `relMSMSIntThr` | `MSPeakLists` | Minimum intensity of mass peaks
`topMSPeaks`, `topMSMSPeaks`                  | `MSPeakLists`                  | Only keep most intense mass peaks
`withMSMS`                                    | `MSPeakLists`                  | Only keep results with MS/MS data
`minExplainedFragPeaks`, `minExplainedPeaks`  | `formulas` / `compounds`       | Minimum number of annotated mass peaks
`elements`, `fragElements`, `lossElements`    | `formulas`, `compounds`        | Restrain elemental composition
`topMost`                                     | `formulas`, `compounds`        | Only keep highest ranked candidates 
`minScore`, `minFragScore`, `minFormulaScore` | `compounds`                    | Minimum compound scorings
`scoreLimits`                                 | `formulas`, `compounds`        | Minimum/Maximum scorings
`OM`                                          | `formulas`                     | Only keep candidates with likely elemental composition found in organic matter

Several intensity related filters are available to clean-up MS peak list data. For instance, the `topMSPeaks`/`topMSMSPeaks` filters provide a simple way to remove noisy data by only retaining a defined number of most intense mass peaks. Note that none of these filters will remove the mass peak of the feature from its MS peak list.

The filters applicable to formula and compound annotation generally concern minimal scoring or chemical properties. The former is useful to remove unlikely candidates, whereas the second is useful to focus on certain study specific chemical properties (e.g. known neutral losses).

Common examples are shown below.

```{r filtAnn,eval=FALSE}
# intensity filtering
mslists <- filter(mslists,
                  absMSIntThr = 500, # minimum MS mass peak intensity of 500
                  relMSMSIntThr = 0.1) # minimum MS/MS mass peak intensity of 10%

# only retain 10 most intens mass peaks
# (feature mass is always retained)
mslists <- filter(mslists, topMSPeaks = 10)

# only keep formulae with 1-10 sulphur or phosphorus elements
formulas <- filter(formulas, elements = c("S1-10", "P1-10"))

# only keep candidates with MS/MS fragments that contain 1-10 carbons and 0-2 oxygens
formulas <- filter(formulas, fragElements = "C1-10O0-2")

# only keep candidates with CO2 neutral loss
formulas <- filter(formulas, lossElements = "CO2")

# only keep the 15 highest ranked candidates with at least 1 annotated MS/MS peak
compounds <- filter(compounds, minExplainedPeaks = 1, topMost = 15)

# minimum in-silico score
compounds <- filter(compounds, minFragScore = 10)

# candidate should be referenced in at least 1 patent
# (only works if database lists number of patents, e.g. PubChem)
compounds <- filter(compounds,
                    scoreLimits = list(numberPatents = c(1, Inf))
```

### Components

- note about presence of data

Finally several filters are available for components:

Filter                       | Remarks
---------------------------- | -----------------
`size`                       | Minimum component size
`adducts`, `isotopes`        | Filter features by adduct/istopes annotation
`rtIncrement`, `mzIncrement` | Filter homologs by retention/mz increment range

Note that these filters are only applied if the components contain the data the filter works on. For instance, filtering by adducts will _not_ affect components obtained from homologous series.

As before, some typical examples are shown below.

```{r filtComp,eval=FALSE}
# only keep components with at least 4 features
componInt <- filter(componInt, minSize = 4)

# remove all features from components are not annotated as an adduct
componRC <- filter(componRC, adducts = TRUE)

# only keep protonated and sodium adducts
componRC <- filter(componRC, adducts = c("[M+H]+", "[M+Na]+"))

# remove all features not recognized as isotopes
componRC <- filter(componCAM, isotopes = FALSE)

# only keep monoisotopic mass
componRC <- filter(componCAM, isotopes = 0)

# min/max rt/mz increments for homologs
componNT <- filter(componNT, rtIncrement = c(10, 30),
                   mzIncrement = c(16, 50))
```

> **_NOTE_** As mentioned before, components are still in a relative young development phase and results should always be verified!

### Negation

All filters support _negation_: if enabled all specified filters will be executed in an opposite manner. Negation may not be so commonly used, but allows greater flexibility which is sometimes needed for advanced filtering steps. Furthermore, it is also useful to specifically isolate the data that otherwise would have been removed. Some examples are shown below.

```{r filtNeg,eval=FALSE}
# keep all features/analyses _not_ present from replicate groups "repl1" and "repl2"
fGroups <- filter(fGroups, rGroups = c("repl1", "repl2"), negate = TRUE)

# only retain features with a mass defect outside 0.8-0.9
fGroups <- filter(mzDefectRange = c(0.8, 0.9), negate = TRUE)

# remove candidates with CO2 neutral loss
formulas <- filter(formulas, lossElements = "CO2", negate = TRUE)

# select 15 worst ranked candidates
compounds <- filter(compounds, topMost = 15, negate = TRUE)

# only keep components with <5 features
componInt <- filter(componInt, minSize = 5, negate = TRUE)
```

## Subsetting {#subset}

The previous section discussed the `filter()` generic function to perform various data cleaning operations. A more generic way to select data is by _subsetting_: here you can manually specify which parts of an object should be retained. Subsetting is supported for all workflow objects and is performed by the R subset operator (`"["`). This operator either subsets by one or two arguments, which are referred to as the `i` and `j` arguments.

Class           | Argument `i`   | Argument `j`   | Remarks
--------------- | -------------- | -------------- | ------------------------------------------------
`features`      | analyses       |                |
`featureGroups` | analyses       | feature groups |
`MSPeakLists`   | analyses       | feature groups | peak lists for feature groups will be re-averaged when subset on analyses (by default)
`formulas`      | feature groups |                | 
`compounds`     | feature groups |                |
`components`    | components     | feature groups |

For objects that support two-dimensional subsetting (e.g. `featureGroups`, `MSPeakLists`), either the `i` or `j` argument is optional. Furthermore, unlike subsetting a `data.frame`, the position of `i` and `j` does not change when only one argument is specified:

```{r subsetArgs,eval=FALSE}
df[1, 1] # subset data.frame by first row/column
df[1] # subset by first column
df[1, ] # subset by first row

fGroups[1, 1] # subset by first analysis/feature group
fGroups[, 1] # subset by first feature group (i.e. column)
fGroups[1] # subset by first analysis (i.e. row)
```

The subset operator allows three types of input:

- A logical vector: elements are selected if corresponding values are `TRUE`.
- A numeric vector: select elements by numeric index.
- A character vector: select elements by their name.

When a logical vector is used as input it will be re-cycled if necessary. For instance, the following will select by the first, third, fifth, etc. analysis.

```{r subsetCyc,eval=FALSE}
fGroups[c(TRUE, FALSE)]
```

In order to select by a `character` you will need to know the names for each element. These can, for instance, be obtained by the `groupNames()` (feature group names), `analyses()` (analysis names) and `names()` (names for components or feature groups for `featureGroups` objects) generic functions.

Some more examples of common subsetting operations are shown below.

```{r subsetting,eval=FALSE}
# select first three analyses
fList[1:3]

# select first three analyses and first 500 feature groups
fGroups[1:3, 1:500]

# select all feature groups from first component
fGroupsNT <- fGroups[, componNT[[1]]$group]

# only keep feature groups with formula annotation results
fGroupsForms <- fGroups[, groupNames(formulas)]

# only keep feature groups with either formula or compound annotation results
fGroupsAnn <- fGroups[, union(groupNames(formulas), groupNames(compounds))]

# select first 15 components
componCAM[1:15]

# select by name
componCAM[c("CMP1", "CMP5")]

# only retain feature groups in components for which compound annotations are
# available
componCAM[, groupNames(compounds)]
```

### Prioritization workflow

An important use case of subsetting is prioritization of data. For instance, after statistical analysis only certain feature groups are deemed relevant for the rest of the workflow. A common prioritization workflow is illustrated below:

```{r prioriWorkflow,echo=FALSE}
DiagrammeR::grViz("
digraph rmarkdown {
  graph [ rankdir = LR ]
  node [ shape = box,
         fixedsize = true,
         width = 2.3,
         height = 1,
         fontsize = 18,
         fillcolor = darkseagreen1,
         style = filled ]

    'Object conversion' -> 'Prioritization' -> Subsetting
}", height = 120, width = 500)
```

During the first step the workflow object is converted to a suitable format, most often using the `as.data.frame()` function. The converted data is then used as input for the prioritization strategy. Finally, these results are then used to select the data of interest in the original object.

A very simplified example of such a process is shown below.

```{r prioriEx,eval=FALSE}
featTab <- as.data.frame(fGroups, average = TRUE)

# prioritization: sort by (averaged) intensity of the "sample" replicate group
# (from high to low) and then obtain the feature group identifiers of the top 5.
featTab <- featTab[order(featTab$standard, decreasing = TRUE), ]
groupsOfInterest <- featTab$group[1:5]

# subset the original data
fGroups <- fGroups[, groupsOfInterest]

# fGroups now only contains the feature groups for which intensity values in the
# "sample" replicate group were in the top 5
```

## Visualization

- Optimization results here?
- Link to compound clust/consensus sections

### Features and annatation data

- highlight subsetting

Several generic functions are available to visualize feature and annotation data:

Generic           | Classes                                              | Remarks
----------------- | ---------------------------------------------------- | ---------------------------------------------------------------
`plot()`          | `featureGroups`, `featureGroupsComparison`           | Scatter plot for retention and _m/z_ values
`plotInt()`       | `featureGroups`                                      | Intensity profiles across analyses
`plotEIC()`       | `featureGroups`, `components`                        | Plot extracted ion chromatograms (EICs)
`plotSpec()`      | `MSPeakLists`, `formulas`, `compounds`, `components` | Plots (annotated) spectra
`plotStructure()` | `compounds`                                          | Draws candidate structures
`plotScores()`    | `formulas`, `compounds`                              | Barplot for candidate scoring

The most common plotting functions are `plotEIC()`, which plots chromatographic data for features, and `plotSpec()`, which will plot (annotated) spectra. An overview of their most important function arguments are shown below.

Argument                                      | Generic                   | Remarks
--------------------------------------------- | ------------------------- | -------------------------------------------------------------------
`rtWindow`                                    | `plotEIC()`               | Extra time (in s) +/- retention limits of plotted features (useful to zoom out)
`mzWindow`                                    | `plotEIC()`               | m/z width of EICs (in Da)
`retMin`                                      | `plotEIC()`               | If `TRUE` plot retention times in minutes
`topMost`                                     | `plotEIC()`               | Only draw this amount of highest intensity features in each group.
`showPeakArea`, `showFGroupRect`              | `plotEIC()`               | Fill peak areas / draw rectangles around feature groups?
`title`                                       | `plotEIC()`, `plotSpec()` | Override plot title
`colourBy`                                    | `plotEIC()`               | Colour individual feature groups (`"fGroups"`) or replicate groups (`"rGroups"`). By default nothing is coloured (`"none"`)
`showLegend`                                  | `plotEIC()`               | Display a legend? (only if `colourBy!="none"`)
`onlyPresent`                                 | `plotEIC()`               | Only plot EICs for analyses where a feature was detected? Setting to `FALSE` is useful to inspect if a feature was 'missed'.
`xlim`, `ylim`                                | `plotEIC()`, `plotSpec()` | Override x/y axis ranges, i.e. to manually set plotting range.
`groupName`, `analysis`, `precursor`, `index` | `plotSpec()`              | What to plot. See examples below.
`MSLevel`                                     | `plotSpec()`              | Whether to plot an MS or MS/MS spectrum (only `MSPeakLists`)
`formulas`                                    | `plotSpec()`              | Whether `formula` annotation should be added (only `compounds`)
`plotStruct`                                  | `plotSpec()`              | Whether the structure should be added to the plot (only `compounds`)

Note that we can use [subsetting](#subset) to select which feature data we want to plot, e.g.

```{r plotEICSub,eval=FALSE}
plotEIC(fGroups[4:6]) # only plot EICs from 4th-6th analyses.
plotEIC(fGroups[, 1]) # only plot all features of first group
```

The `plotStructure()` function will draw a chemical structure for a compound candidate. In addition, this function can draw the maximum common substructure (MCS) of multiple candidates in order to assess common structural features.

```{r plotStruct,eval=FALSE}
# structure for first candidate
plotStructure(compounds, index = 1, groupName = "M109_R116_61")
# MCS for first three candidates
plotStructure(compounds, index = 1:3, groupName = "M109_R116_61")
```

Some other common and less common plotting operations are shown below.

```{r plotFeatAnn,eval=FALSE}
plot(fGroups) # simple scatter plot of retention and m/z values
plotInt(fGroups) # simple line plot of all intensities

plotEIC(fGroups) # plot EICs for all features
# get overview of all feature groups
plotEIC(fGroups,
        colourBy = "fGroup", # unique colour for each group
        topMost = 1, # only most intense feature in each group
        showPeakArea = TRUE, # show integrated areas
        showFGroupRect = FALSE,
        showLegend = FALSE) # no legend (too busy for many feature groups)
plotEIC(fGroups[, 1], # only plot all features of first group
        colourBy = "rGroup") # and mark them individually per replicate group

plotSpec(mslist, "M109_R116_61") # non-annotated MS spectrum
plotSpec(mslist, "M109_R116_61", MSLevel = 2) # non-annotated MS/MS spectrum
# formula annotated spectrum
plotSpec(forms, precursor = "C6H9N2", groupName = "M109_R116_61",
         MSPeakLists = plists)
# compound annotated spectrum, with added formula annotations
plotSpec(compounds, index = 1, groupName = "M109_R116_61", MSPeakLists = plists,
         formulas = formulas)
# custom intensity range (e.g. to zoom in)
plotSpec(compounds, index = 1, groupName = "M109_R116_61", MSPeakLists = plists,
         ylim = c(0, 5000))
```

### Comparing data

There are three functions that can be used to asses overlap and uniqueness between data:

Generic     | Classes
----------- | ------------------------------------------------------------------- 
`plotVenn`  | `featureGroups`, `featureGroupsComparison`, `formulas`, `compounds` 
`plotUpSet` | `featureGroups`, `featureGroupsComparison`, `formulas`, `compounds` 
`plotChord` | `featureGroups`, `featureGroupsComparison`

The most simple comparison plot is a Venn diagram (i.e. `plotVenn()`). This function is especially useful for two or three-way comparisons. More complex comparisons are better visualized with [UpSet] diagrams (i.e. `plotUpSet()`). Finally, chord diagrams (i.e. `plotChord()`) provide visually pleasing diagrams to assess overlap between data.

<!-- UNDONE: also link to overlap/unique -->

These functions can either be used to compare feature data or different objects of the same type. The former is typically used to compare overlap or uniqueness between features in different replicate groups, whereas comparison between objects is useful to visualize differences in algorithmic output (see [algorithm consensus](#consensus) for more advanced functionality to do so).

As usual, some examples are shown below.

```{r plotComp,eval=FALSE}
plotUpSet(fGroups) # compare replicate groups
plotVenn(fGroups, which = c("repl1", "repl2")) # compare some replicate groups
plotChord(fGroups, average = TRUE) # overlap between replicate groups
# compare with custom made groups: surface and ground
plotChord(fGroups, outer = c(sw1 = "surface", sw2 = "surface", sw3 = "surface",
                             gw1 = "ground", gw2 = "ground", gw3 = "ground"))

# compare MetFrag and SIRIUS results
plotVenn(compoundsMF, compoundsSIR)
plotVenn(compoundsMF, compoundsSIR,
         labels = c("MF", "SIR")) # manual labelling
```

### Hierarchical clustering results {#plotClust}

In `patRoon` hierarchical clustering is used to generate components based on their intensity profiles (see [intensity clustering](#intclust)) and to cluster candidate compounds with similar chemical structure (see [compound clustering](#compclust)). The functions below can be used to visualize their results.

Generic             | Classes                                  | Remarks
------------------- | ---------------------------------------- | --------------------------------------------------
`plot()`            | `componentsIntClust`, `compoundsCluster` | Plots a dendrogram
`plotInt()`         | `componentsIntClust`                     | Plots normalized intensity profiles in a cluster
`plotHeatMap()`     | `componentsIntClust`                     | Plots an heatmap
`plotSilhouettes()` | `componentsIntClust`                     | Plot silhouette information to determine the cluster amount
`plotStructure()`   | `compoundsCluster`                       | Plots the maximum common substructure (MCS) of a cluster


```{r plotClust,eval=FALSE}
plot(componInt) # dendrogram
plot(compsClust, groupName = "M109_R116_64") # dendrogram for clustered compounds

plotInt(componInt, index = 2) # intensities of 2nd cluster
plotHeatMap(componInt) # plot heatmap
plotHeatMap(componInt, interactive = TRUE) # interactive heatmap
plotSilhouettes(componInt, 2:10) # plot silhouettes (e.g. to obtain ideal cluster amount)
```

## Reporting

The previous sections showed various functionalies to inspect and visualize results. An easy and automated way to do this automatically is by using the _reporting_ functionality of `patRoon`. The following three reporting functions are available:

- `reportCSV()`: exports workflow data to comma-separated value (csv) files
- `reportPDF()`: generates simple reports by plotting workflow data in portable document files (PDFs)
- `reportMD()`: generates interactive and easily explorable reports

There are many different arguments available to configure the reporting process. Some common arguments are listed below; for a complete listing see the reference manual (e.g. `?reporting`).

Argument                              | Functions                   | Remarks
------------------------------------- | --------------------------- | ----------------------------------------------------------
`fGroups`, `formulas`, `compounds`, `formulas`, `components`, `compsCluster` | All | Objects to plot. Only `fGroups` is mandatory.
`MSPeakLists`                         | `reportPDF()`, `reportMD()` | The `MSPeakLists` object that was used to generate annotation data. Only needs to be specified if `formulas` or `compounds` are reported.
`path`                                | All                         | Directory path where report files will be stored (`"report"` by default).
`formulasTopMost`, `compoundsTopMost` | `reportPDF()`, `reportMD()` | Report no more than this amount of highest ranked candidates.
`EICOnlyPresent`                      | `reportPDF()`, `reportMD()` | Only plot an EIC for an analysis if a feature was detected.
`selfContained`                       | `reportMD()`                | Outputs to a single and self contained `.html` file. Handy to share reports, but not recommended for large amounts of data.

Which data will be reported is fully configurable. The only workflow object that must be specified are the feature groups (i.e. with the `fGroups` argument), all other data (e.g. `compounds`, `components`) are optional. This means that reporting can be performed at every stage during the workflow, which, for instance, can be useful to quickly inspect results when testing out various settings to generate workflow data.

When formula or compound results are reported with `reportPDF()` or `reportMD()` then only the top ranked candidates are considered. This limtation is often necessary as reporting many candidates will take considerable time. By default the top 5 for each feature group are reported, however, this number can be changed with the `formulasTopMost` and `compoundsTopMost` arguments.

Some typical examples:

```{r reporting,eval=FALSE}
reportMD(fGroups) # simple interactive report with feature data
# generate PDFs with feature and compound annotation data
reportPDF(fGroups, compounds = compounds, MSPeakLists = mslists)
reportCSV(fGroups, path = "myReport") # change destination path

# generate report with all workflow types and increase maximum number of
# compound candidates to top 10
reportMD(fGroups, formulas = formulas, compounds = compounds,
         components = componCAM, MSPeakLists = mslists,
         compsCluster = compsClust,
         compoundsTopMost = 10)
```
