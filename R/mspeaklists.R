#' @include main.R
NULL

#' Class containing MS Peak Lists
#'
#' Contains all MS (and MS/MS where available) peak lists for a
#' \code{\link{featureGroups}} object.
#'
#' Objects for this class are returned by \link[=MSPeakLists-generation]{MS peak
#' lists generators}.
#'
#' @slot peakLists Contains a list of all MS (and MS/MS) peak lists. Use the
#'   \code{peakLists} method for access.
#' @slot algorithm The algorithm that was used to generate the MS peak lists.
#'   Use the \code{algorithm} method for access.
#'
#' @param obj,x,object The \code{\link{MSPeakLists}} object to access.
#' @export
MSPeakLists <- setClass("MSPeakLists",
                         slots = c(peakLists = "list", algorithm = "character"),
                         prototype = list(peakLists = list(), algorithm = "none"))

#' @describeIn MSPeakLists Accessor method to obtain the MS peak lists.
#' @return \code{peakLists} returns a nested list containing MS (and MS/MS where
#'   available) peak lists per feature group and per analysis. The format is:
#'   \code{[[analysis]][[featureGroupName]][[MSType]][[PeakLists]]} where
#'   \code{MSType} is either \code{"MS"} or \code{"MSMS"} and \code{PeakLists} a
#'   \code{\link{data.table}} containing all \emph{m/z} values (\code{mz}
#'   column) and their intensities (\code{intensity} column). In addition, the
#'   peak list tables may contain a \code{cmp} column which contains an unique
#'   alphabatical identifier to which isotopic cluster (or "compound") a mass
#'   belongs (only supported by MS peak lists generated by Bruker tools at the
#'   moment).
#'
#' @aliases peakLists
#' @export
setMethod("peakLists", "MSPeakLists", function(obj) obj@peakLists)

#' @templateVar class MSPeakLists
#' @templateVar what analyses
#' @template strmethod
#' @export
setMethod("analyses", "MSPeakLists", function(obj) names(obj@peakLists))

#' @templateVar class MSPeakLists
#' @templateVar what feature groups
#' @template strmethod
#' @export
setMethod("groupNames", "MSPeakLists", function(obj) unique(unlist(sapply(obj@peakLists, names, simplify = FALSE), use.names = FALSE)))

#' @describeIn MSPeakLists Retrieve the algorithm (a character string) used to
#'   generate the MS peak lists.
#' @export
setMethod("algorithm", "MSPeakLists", function(obj) obj@algorithm)

#' @describeIn MSPeakLists Obtain total number of \emph{m/z} values.
#' @export
setMethod("length", "MSPeakLists", function(x) sum(unlist(recursiveApplyDT(x@peakLists, nrow))))

#' @describeIn MSPeakLists Shows summary information for this object.
#' @export
setMethod("show", "MSPeakLists", function(object)
{
    if (length(object) == 0)
    {
        mspcount <- msmspcount <- totpcount <- totpcount <- mslcount <- msmslcount <- totlcount <- 0
        amspcount <- amsmspcount <- atotpcount <- atotpcount <- amslcount <- amsmslcount <- atotlcount <- 0
    }
    else
    {
        mspcount <- sum(sapply(object@peakLists, function(pa) sum(sapply(pa, function(pf) if (!is.null(pf[["MS"]])) nrow(pf[["MS"]]) else 0))))
        msmspcount <- sum(sapply(object@peakLists, function(pa) sum(sapply(pa, function(pf) if (!is.null(pf[["MSMS"]])) nrow(pf[["MSMS"]]) else 0))))
        totpcount <- sum(mspcount, msmspcount)
        mslcount <- sum(lengths(object@peakLists))
        msmslcount <- sum(sapply(object@peakLists, function(pa) sum(sapply(pa, function(pf) !is.null(pf[["MSMS"]])))))
        totlcount <- sum(mslcount, msmslcount)
        
        anacount <- length(object@peakLists)
        atotpcount <- totpcount / anacount
        amspcount <- mspcount / anacount
        amsmspcount <- msmspcount / anacount
        atotlcount <- totlcount / anacount
        amslcount <- mslcount / anacount
        amsmslcount <- msmslcount / anacount
    }

    printf("A MSPeakLists object ('%s')\n", class(object))
    printf("Total peak count: %d (MS: %d - MS/MS: %d)\n", totpcount, mspcount, msmspcount)
    printf("Average peak count/analysis: %.0f (MS: %.0f - MS/MS: %.0f)\n", atotpcount,
           amspcount, amsmspcount)
    printf("Total peak lists: %d (MS: %d - MS/MS: %d)\n", totlcount, mslcount, msmslcount)
    printf("Average peak lists/analysis: %.0f (MS: %.0f - MS/MS: %.0f)\n", atotlcount,
           amslcount, amsmslcount)
    showObjectSize(object)
})

#' @templateVar class MSPeakLists
#' @templateVar whati analyses
#' @templateVar orderi analyses()
#' @templateVar whatj feature groups
#' @templateVar orderj groupNames()
#' @template extr_op-args
#'
#' @export
setMethod("[", c("MSPeakLists", "ANY", "ANY", "ANY"), function(x, i, j, ..., drop = TRUE)
{
    if (!missing(i))
        assertExtractArg(i)
    if (!missing(j))
        assertExtractArg(j)
    
    # non-existing indices result in NULL values --> prune
    
    if (!missing(i))
    {
        if (!is.character(i))
            i <- analyses(x)[i]
        x@peakLists <- pruneList(x@peakLists[i])
    }
    
    if (!missing(j))
    {
        if (!is.character(j))
            j <- groupNames(x)[j]
        x@peakLists <- sapply(x@peakLists, function(a)
        {
            ret <- a[j]
            return(pruneList(ret))
        }, simplify = FALSE)
        x@peakLists <- pruneList(x@peakLists, TRUE)
    }
    
    return(x)
})

#' @describeIn MSPeakLists provides post filtering of generated MS
#'   peak lists, which may further enhance quality of subsequent workflow steps
#'   (\emph{e.g.} formulae calculation and compounds identification) and/or
#'   speed up these processes.
#'
#' @param absMSIntThr,absMSMSIntThr,relMSIntThr,relMSMSIntThr Absolute/relative
#'   intensity threshold for MS or MS/MS peak lists. \code{NULL} for none.
#' @param topMSPeaks,topMSMSPeaks Only consider this amount of MS or MS/MS peaks
#'   with highest intensity. \code{NULL} to consider all.
#' @param deIsotopeMS,deIsotopeMSMS Remove any isotopic peaks in MS or MS/MS
#'   peak lists. This may improve data processing steps which do not assume the
#'   presence of isotopic peaks (e.g. MetFrag for MS/MS). Note that
#'   \code{getMzRPeakLists} does not (yet) support flagging of isotopes.
#'
#' @export
setMethod("filter", "MSPeakLists", function(obj, absMSIntThr = NULL, absMSMSIntThr = NULL, relMSIntThr = NULL,
                                            relMSMSIntThr = NULL, topMSPeaks = NULL, topMSMSPeaks = NULL,
                                            deIsotopeMS = FALSE, deIsotopeMSMS = FALSE)
{
    ac <- checkmate::makeAssertCollection()
    aapply(checkmate::assertNumber, . ~ absMSIntThr + absMSMSIntThr + relMSIntThr + relMSMSIntThr,
           lower = 0, finite = TRUE, null.ok = TRUE, fixed = list(add = ac))
    aapply(checkmate::assertCount, . ~ topMSPeaks + topMSMSPeaks, positive = TRUE,
           null.ok = TRUE, fixed = list(add = ac))
    aapply(checkmate::assertFlag, . ~ deIsotopeMS + deIsotopeMSMS, fixed = list(add = ac))
    checkmate::reportAssertions(ac)
    
    if (length(obj) == 0)
        return(obj)
    
    hash <- makeHash(obj, absMSIntThr, absMSMSIntThr, relMSIntThr, relMSMSIntThr,
                     topMSPeaks, topMSMSPeaks, deIsotopeMS, deIsotopeMSMS)
    cache <- loadCacheData("filterMSPeakLists", hash)
    if (!is.null(cache))
        return(cache)

    pLists <- peakLists(obj)

    for (anai in seq_along(pLists))
    {
        gcount <- length(pLists[[anai]])
        printf("Filtering MS peak lists for %d feature groups in analysis '%s'...\n", gcount,
               names(pLists)[anai])
        prog <- txtProgressBar(0, gcount, style = 3)

        for (grpi in seq_along(pLists[[anai]]))
        {
            if (!is.null(absMSIntThr))
                pLists[[anai]][[grpi]][["MS"]] <- pLists[[anai]][[grpi]][["MS"]][intensity >= absMSIntThr]

            if (!is.null(relMSIntThr) && nrow(pLists[[anai]][[grpi]][["MS"]]) > 0)
            {
                thr <- max(pLists[[anai]][[grpi]][["MS"]]$intensity) * relMSIntThr
                pLists[[anai]][[grpi]][["MS"]] <- pLists[[anai]][[grpi]][["MS"]][intensity >= thr]
            }

            if (!is.null(topMSPeaks) && nrow(pLists[[anai]][[grpi]][["MS"]]) > topMSPeaks)
            {
                ord <- order(-pLists[[anai]][[grpi]][["MS"]]$intensity)
                pLists[[anai]][[grpi]][["MS"]] <- pLists[[anai]][[grpi]][["MS"]][ord[seq_len(topMSPeaks)]]
            }

            if (deIsotopeMS)
                pLists[[anai]][[grpi]][["MS"]] <- deIsotopeMSPeakList(pLists[[anai]][[grpi]][["MS"]])

            if (!is.null(pLists[[anai]][[grpi]][["MSMS"]]))
            {
                if (!is.null(absMSMSIntThr) && !is.null(pLists[[anai]][[grpi]][["MSMS"]]))
                    pLists[[anai]][[grpi]][["MSMS"]] <- pLists[[anai]][[grpi]][["MSMS"]][intensity >= absMSMSIntThr]

                if (!is.null(relMSMSIntThr) && nrow(pLists[[anai]][[grpi]][["MS"]]) > 0)
                {
                    thr <- max(pLists[[anai]][[grpi]][["MSMS"]]$intensity) * relMSMSIntThr
                    pLists[[anai]][[grpi]][["MSMS"]] <- pLists[[anai]][[grpi]][["MSMS"]][intensity >= thr]
                }

                if (!is.null(topMSMSPeaks) && nrow(pLists[[anai]][[grpi]][["MSMS"]]) > topMSMSPeaks)
                {
                    ord <- order(-pLists[[anai]][[grpi]][["MSMS"]]$intensity)
                    pLists[[anai]][[grpi]][["MSMS"]] <- pLists[[anai]][[grpi]][["MSMS"]][ord[seq_len(topMSMSPeaks)]]
                }

                if (deIsotopeMSMS)
                    pLists[[anai]][[grpi]][["MSMS"]] <- deIsotopeMSPeakList(pLists[[anai]][[grpi]][["MSMS"]])
            }
            
            # prune empty
            if (!is.null(pLists[[anai]][[grpi]][["MS"]]) && nrow(pLists[[anai]][[grpi]][["MS"]]) == 0)
                pLists[[anai]][[grpi]][["MS"]] <- NULL
            if (!is.null(pLists[[anai]][[grpi]][["MSMS"]]) && nrow(pLists[[anai]][[grpi]][["MSMS"]]) == 0)
                pLists[[anai]][[grpi]][["MSMS"]] <- NULL
            
            setTxtProgressBar(prog, grpi)
        }
        
        # prune empty
        empties <- sapply(pLists[[anai]], function(pg) is.null(pg[["MS"]]) && is.null(pg[["MSMS"]]))
        pLists[[anai]] <- pLists[[anai]][!empties]

        setTxtProgressBar(prog, gcount)
        close(prog)
    }

    obj@peakLists <- pLists
    saveCacheData("filterMSPeakLists", obj, hash)

    return(obj)
})

#' @templateVar class MSPeakLists
#' @template filterby
#' @param onlyMSMS If \code{TRUE} then only keep feature groups that have MS/MS
#'   peaklists.
#' @export
setMethod("filterBy", "MSPeakLists", function(obj, fGroups, negate, onlyMSMS = FALSE)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", add = ac)
    aapply(checkmate::assertFlag, . ~ negate + onlyMSMS, fixed = list(add = ac))
    checkmate::reportAssertions(ac)
    
    if (length(obj) == 0)
        grps <- character()
    else
    {
        if (onlyMSMS)
        {
            grps <- unique(unlist(sapply(peakLists(obj),
                                         function(pa) ifelse(sapply(pa, function(pg) !is.null(pg[["MSMS"]])), names(pa), NA))))
            grps <- grps[!is.na(grps)]
        }
        else
            grps <- unique(unlist(sapply(peakLists(obj), function(pa) names(pa))))
    }
    
    return(groupNamesFilter(fGroups, "mspeaklists", grps, negate, hashParam = c(grps, negate, onlyMSMS)))
})

#' @templateVar func generateMSPeakLists
#' @templateVar what generate MS peak lists
#' @templateVar ex1 generateFormulasDA
#' @templateVar ex2 generateFormulasGenForm
#' @templateVar algos bruker,brukerfmf,mzr
#' @template generic-algo
#'
#' @param \dots Any parameters to be passed to the selected MS peak lists
#'   generation algorithm.
#'
#' @rdname MSPeakLists-generation
#' @aliases generateMSPeakLists
#' @export
setMethod("generateMSPeakLists", "featureGroups", function(fGroups, algorithm, ...)
{
    f <- switch(algorithm,
                bruker = generateDAMSPeakLists,
                brukerfmf = generateDAFMFMSPeakLists,
                mzr = generateMzRPeakLists,
                stop("Invalid algorithm! Should be: bruker, brukerfmf or mzr"))

    f(fGroups, ...)
})

