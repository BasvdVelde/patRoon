#' @include main.R
NULL

#' Class containing MS Peak Lists
#'
#' Contains all MS (and MS/MS where available) peak lists for a
#' \code{\link{featureGroups}} object.
#'
#' Objects for this class are returned by \link[=MSPeakLists-generation]{MS peak
#' lists generators}.
#'
#' @slot peakLists Contains a list of all MS (and MS/MS) peak lists. Use the
#'   \code{peakLists} method for access.
#' @slot algorithm The algorithm that was used to generate the MS peak lists.
#'   Use the \code{algorithm} method for access.
#'
#' @param obj,x,object The \code{\link{MSPeakLists}} object to access.
#' @export
MSPeakLists <- setClass("MSPeakLists",
                         slots = c(peakLists = "list", algorithm = "character"),
                         prototype = list(peakLists = list(), algorithm = "none"))

#' @describeIn MSPeakLists Accessor method to obtain the MS peak lists.
#' @return \code{peakLists} returns a nested list containing MS (and MS/MS where
#'   available) peak lists per feature group and per analysis. The format is:
#'   \code{[[analysis]][[featureGroupName]][[MSType]][[PeakLists]]} where
#'   \code{MSType} is either \code{"MS"} or \code{"MSMS"} and \code{PeakLists} a
#'   \code{\link{data.table}} containing all \emph{m/z} values (\code{mz}
#'   column) and their intensities (\code{intensity} column). In addition, the
#'   peak list tables may contain a \code{cmp} column which contains an unique
#'   alphabatical identifier to which isotopic cluster (or "compound") a mass
#'   belongs (only supported by MS peak lists generated by Bruker tools at the
#'   moment).
#'
#' @aliases peakLists
#' @export
setMethod("peakLists", "MSPeakLists", function(obj) obj@peakLists)

#' @describeIn MSPeakLists Retrieve the algorithm (a character string) used to
#'   generate the MS peak lists.
#' @export
setMethod("algorithm", "MSPeakLists", function(obj) obj@algorithm)

#' @describeIn MSPeakLists Obtain total number of \emph{m/z} values.
#' @export
setMethod("length", "MSPeakLists", function(x) sum(unlist(recursiveApplyDT(x@peakLists, nrow))))

#' @describeIn MSPeakLists Shows summary information for this object.
#' @export
setMethod("show", "MSPeakLists", function(object)
{
    mspcount <- sum(sapply(object@peakLists, function(pa) sum(sapply(pa, function(pf) nrow(pf$MS)))))
    msmspcount <- sum(sapply(object@peakLists, function(pa) sum(sapply(pa, function(pf) if (!is.null(pf$MSMS)) nrow(pf$MSMS) else 0))))
    totpcount <- sum(mspcount, msmspcount)
    mslcount <- sum(lengths(object@peakLists))
    msmslcount <- sum(sapply(object@peakLists, function(pa) sum(sapply(pa, function(pf) !is.null(pf$MSMS)))))
    totlcount <- sum(mslcount, msmslcount)
    anacount <- length(object@peakLists)

    printf("A MSPeakLists object ('%s')\n", class(object))
    printf("Total peak count: %d (MS: %d - MS/MS: %d)\n", totpcount, mspcount, msmspcount)
    printf("Average peak count/analysis: %.0f (MS: %.0f - MS/MS: %.0f)\n", totpcount / anacount,
           mspcount / anacount, msmspcount / anacount)
    printf("Total peak lists: %d (MS: %d - MS/MS: %d)\n", totlcount, mslcount, msmslcount)
    printf("Average peak lists/analysis: %.0f (MS: %.0f - MS/MS: %.0f)\n", totlcount / anacount,
           mslcount / anacount, msmslcount / anacount)
    showObjectSize(object)
})

#' @describeIn MSPeakLists provides post filtering of generated MS
#'   peak lists, which may further enhance quality of subsequent workflow steps
#'   (\emph{e.g.} formulae calculation and compounds identification) and/or
#'   speed up these processes.
#'
#' @param absMSIntThr,absMSMSIntThr,relMSIntThr,relMSMSIntThr Absolute/relative
#'   intensity threshold for MS or MS/MS peak lists. \code{NULL} for none.
#' @param topMSPeaks,topMSMSPeaks Only consider this amount of MS or MS/MS peaks
#'   with highest intensity. \code{NULL} to consider all.
#' @param deIsotopeMS,deIsotopeMSMS Remove any isotopic peaks in MS or MS/MS
#'   peak lists. This may improve data processing steps which do not assume the
#'   presence of isotopic peaks (e.g. MetFrag for MS/MS). Note that
#'   \code{getMzRPeakLists} does not (yet) support flagging of isotopes.
#'
#' @export
setMethod("filter", "MSPeakLists", function(obj, absMSIntThr = NULL, absMSMSIntThr = NULL, relMSIntThr = NULL,
                                            relMSMSIntThr = NULL, topMSPeaks = NULL, topMSMSPeaks = NULL,
                                            deIsotopeMS = FALSE, deIsotopeMSMS = FALSE)
{
    hash <- makeHash(obj, absMSIntThr, absMSMSIntThr, relMSIntThr, relMSMSIntThr,
                     topMSPeaks, topMSMSPeaks, deIsotopeMS, deIsotopeMSMS)
    cache <- loadCacheData("filterMSPeakLists", hash)
    if (!is.null(cache))
        return(cache)

    pLists <- peakLists(obj)

    for (anai in seq_along(pLists))
    {
        gcount <- length(pLists[[anai]])
        printf("Filtering MS peak lists for %d feature groups in analysis '%s'...\n", gcount,
               names(pLists)[anai])
        prog <- txtProgressBar(0, gcount, style = 3)

        for (grpi in seq_along(pLists[[anai]]))
        {
            if (!is.null(absMSIntThr))
                pLists[[anai]][[grpi]]$MS <- pLists[[anai]][[grpi]]$MS[intensity >= absMSIntThr]

            if (!is.null(relMSIntThr))
            {
                thr <- max(pLists[[anai]][[grpi]]$MS$intensity) * relMSIntThr
                pLists[[anai]][[grpi]]$MS <- pLists[[anai]][[grpi]]$MS[intensity >= thr]
            }

            if (!is.null(topMSPeaks) && nrow(pLists[[anai]][[grpi]]$MS) > topMSPeaks)
            {
                ord <- order(-pLists[[anai]][[grpi]]$MS$intensity)
                pLists[[anai]][[grpi]]$MS <- pLists[[anai]][[grpi]]$MS[ord[seq_len(topMSPeaks)]]
            }

            if (deIsotopeMS)
                pLists[[anai]][[grpi]]$MS <- deIsotopeMSPeakList(pLists[[anai]][[grpi]]$MS)

            if (!is.null(pLists[[anai]][[grpi]]$MSMS))
            {
                if (!is.null(absMSMSIntThr) && !is.null(pLists[[anai]][[grpi]]$MSMS))
                    pLists[[anai]][[grpi]]$MSMS <- pLists[[anai]][[grpi]]$MSMS[intensity >= absMSMSIntThr]

                if (!is.null(relMSMSIntThr))
                {
                    thr <- max(pLists[[anai]][[grpi]]$MSMS$intensity) * relMSMSIntThr
                    pLists[[anai]][[grpi]]$MSMS <- pLists[[anai]][[grpi]]$MSMS[intensity >= thr]
                }

                if (!is.null(topMSMSPeaks) && nrow(pLists[[anai]][[grpi]]$MSMS) > topMSMSPeaks)
                {
                    ord <- order(-pLists[[anai]][[grpi]]$MSMS$intensity)
                    pLists[[anai]][[grpi]]$MSMS <- pLists[[anai]][[grpi]]$MSMS[ord[seq_len(topMSMSPeaks)]]
                }

                if (deIsotopeMSMS)
                    pLists[[anai]][[grpi]]$MSMS <- deIsotopeMSPeakList(pLists[[anai]][[grpi]]$MSMS)
            }

            setTxtProgressBar(prog, grpi)
        }

        setTxtProgressBar(prog, gcount)
        close(prog)
    }

    obj@peakLists <- pLists
    saveCacheData("filterMSPeakLists", obj, hash)

    return(obj)
})

#' @templateVar func generateMSPeakLists
#' @templateVar what generate MS peak lists
#' @templateVar ex1 generateFormulasDA
#' @templateVar ex2 generateFormulasGenForm
#' @templateVar algos bruker,brukerfmf,mzr
#' @template generic-algo
#'
#' @param \dots Any parameters to be passed to the selected MS peak lists
#'   generation algorithm.
#'
#' @rdname MSPeakLists-generation
#' @aliases generateMSPeakLists
#' @export
setMethod("generateMSPeakLists", "featureGroups", function(fGroups, algorithm, ...)
{
    f <- switch(algorithm,
                bruker = generateDAMSPeakLists,
                brukerfmf = generateDAFMFMSPeakLists,
                mzr = generateMzRPeakLists,
                stop("Invalid algorithm! Should be: bruker, brukerfmf or mzr"))

    f(fGroups, ...)
})

