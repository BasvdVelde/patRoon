#' @include main.R
#' @include components.R
NULL

#' @export
componentsIntClust <- setClass("componentsIntClust",
                               slots = c(clusterm = "matrix", distm = "dissimilarity", clust = "hclust",
                                         cutClusters = "numeric", properties = "list"),
                               contains = "components")


#' @describeIn componentsIntClust Accessor method to the \code{clust} slot,
#'   which was generated by \code{\link{hclust}}.
#' @export
setMethod("clusters", "componentsIntClust", function(obj) obj@clust)

#' @describeIn componentsIntClust Accessor method to the \code{cutClusters}
#'   slot. Returns a vector with cluster membership for each candidate (format
#'   as \code{\link{cutree}}).
#' @export
setMethod("cutClusters", "componentsIntClust", function(obj) obj@cutClusters)

#' @describeIn componentsIntClust Returns a list with properties on how the
#'   clustering was performed.
#' @export
setMethod("clusterProperties", "componentsIntClust", function(obj) obj@properties)

#' @describeIn componentsIntClust Manually (re-)cut the dendrogram.
#' @param k,h Desired number of clusters or tree height to be used for cutting
#'   the dendrogram, respecitively. One or the other must be specified.
#'   Analogous to \code{\link{cutree}}.
#' @export
setMethod("treeCut", "componentsIntClust", function(obj, k = NULL, h = NULL)
{
    if (is.null(k) && is.null(h))
        stop("Either k or h should be specified")
    
    ac <- checkmate::makeAssertCollection()
    checkmate::assertCount(k, positive = TRUE, null.ok = TRUE, add = ac)
    checkmate::assertNumber(h, lower = 0, finite = TRUE, null.ok = TRUE, add = ac)
    checkmate::reportAssertions(ac)
    
    obj@cutClusters <- cutree(obj@clust, k, h)
    return(obj)
})

#' @describeIn componentsIntClust Automatically (re-)cut the dendrogram using
#'   the \code{\link{cutreeDynamicTree}} function from
#'   \pkg{\link{dynamicTreeCut}}.
#'
#' @template dynamictreecut
#'
#' @export
setMethod("treeCutDynamic", "componentsIntClust", function(obj, maxTreeHeight, deepSplit,
                                                           minModuleSize)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertNumber(maxTreeHeight, 0, finite = TRUE, add = ac)
    checkmate::assertFlag(deepSplit, add = ac)
    checkmate::assertCount(minModuleSize, positive = TRUE, add = ac)
    checkmate::reportAssertions(ac)
    
    obj@cutClusters <- doDynamicTreeCut(obj@clust, maxTreeHeight,
                                        deepSplit, minModuleSize)
    return(obj)
})

#' @describeIn componentsIntClust draws a heatmap using the
#'   \code{\link{heatmap}} or \code{\link{d3heatmap}} function.
#' @param interactive If \code{TRUE} an interactive heatmap will be drawn (with
#'   \code{\link{d3heatmap}}).
#' @return \code{drawHeatMap} returns the same as \code{\link{heatmap}} or
#'   \code{\link{d3heatmap}}.
#' @aliases drawHeatMap
#' @export
setMethod("drawHeatMap", "componentsIntClust", function(obj, col, interactive, ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertCharacter(col, min.chars = 1, any.missing = FALSE, add = ac)
    checkmate::assertFlag(interactive, add = ac)
    checkmate::reportAssertions(ac)
    
    if (interactive)
        d3heatmap::d3heatmap(obj@clusterm, Colv = NA, distfun = function(d) dist(d, obj@metric), hclustfun = function(h) hclust(h, obj@method),
                             scale = "none", colors = col, ...)
    else
        heatmap(obj@clusterm, Colv = NA, distfun = function(d) dist(d, obj@metric), hclustfun = function(h) hclust(h, obj@method),
                scale = "none", col = col, ...)
})

#' @describeIn componentsIntClust makes a plot for all (normalized) intensity
#'   profiles of the feature groups within a given cluster.
#' @export
setMethod("plotInt", "componentsIntClust", function(obj, cluster, ...)
{
    checkmate::assertInt(cluster, lower = 1, upper = length(obj@cutClusters), null.ok = TRUE)
    
    plotm <- obj@clusterm[rownames(obj@clusterm) %in% names(obj@cutClusters)[obj@cutClusters == cluster], ]
    nsamp <- ncol(plotm)
    
    plot(x = c(0, nsamp), y = c(0, max(plotm)), type = "n", xlab = "", ylab = "normalized intensity", xaxt = "n", ...)
    axis(1, seq_len(nsamp), colnames(plotm), las = 2)
    
    px <- seq_len(nsamp)
    for (i in seq_len(nrow(plotm)))
        lines(x = px, y = plotm[i, ])
})

#' @describeIn componentsIntClust generates a dendrogram from a given cluster
#'   object and optionally highlights resulting branches when the cluster is
#'   cut.
#' @param pal Colour palette to be used from \pkg{\link{RColorBrewer}}.
#' @param numericLabels Set to \code{TRUE} to label with numeric indices instead
#'   of (long) feature group names.
#' @param \dots Any arguments directly given to \code{\link{plot.dendrogram}}.
#' @export
setMethod("plot", "componentsIntClust", function(x, pal = "Paired", numericLabels = TRUE, ...)
{
    checkmate::assertString(pal, min.chars = 1)
    dendro <- as.dendrogram(x@clust)
    if (numericLabels)
        dendextend::labels(dendro) <- seq_along(x@cutClusters)
    plotDendroWithClusters(dendro, x@cutClusters, pal, ...)
    invisible(NULL)
})

#' @describeIn componentsIntClust Plots the average silhouette width when the
#'   clusters are cut by a sequence of k numbers. The k value with the highest
#'   value (marked in the plot) may be considered as the optimal number of
#'   clusters.
#' @param kSeq An integer vector containing the sequence that should be used for
#'   average silhouette width calculation.
#' @param \dots Any arguments directly given to \code{\link{plot}}.
#' @export
setMethod("plotSilhouettes", "componentsIntClust", function(obj, kSeq, ...)
{
    checkmate::assertIntegerish(kSeq, lower = 2, any.missing = FALSE)
    
    silInfo <- vector("list", length(kSeq))
    maxmw <- maxk <- NULL
    
    meanws <- sapply(kSeq, function(k)
    {
        sil <- silhouette(cutree(obj@clust, k = k), obj@distm)
        summary(sil)$avg.width
    })
    
    plot(x = kSeq, y = meanws, pch = 16, type = "b", xaxt = "none",
         xlab = "cluster k", ylab = "mean silhouette width", ...)
    axis(1, kSeq)
    abline(v = kSeq[which.max(meanws)], lty = 2)
    
    invisible(NULL)
})

generateComponentsIntClust <- function(fGroups, method = "complete", metric = "euclidean", 
                                       normFunc = max, average = TRUE,
                                       maxTreeHeight = 1, deepSplit = TRUE,
                                       minModuleSize = 1)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", add = ac)
    checkmate::assertFunction(normFunc, add = ac)
    checkmate::assertString(metric, add = ac)
    checkmate::assertString(method, add = ac)
    checkmate::assertFlag(average, add = ac)
    checkmate::reportAssertions(ac)
    
    if (average)
    {
        gTable <- averageGroups(fGroups)
        analysis <- unique(analysisInfo(fGroups)$group)
    }
    else
    {
        gTable <- groups(fGroups)
        analysis <- analysisInfo(fGroups)$analysis
    }
    
    clusterdt <- copy(gTable)
    
    cat("Normalizing data... ")
    normv <- clusterdt[, lapply(.SD, normFunc)]
    for (g in seq_along(clusterdt))
        set(clusterdt, j = g, value = clusterdt[[g]] / normv[[g]])
    cat("Done!\n")
    
    clusterm <- as.matrix(transpose(clusterdt))
    rownames(clusterm) <- colnames(gTable)
    colnames(clusterm) <- analysis
    
    cat("Calculating distance matrix... ")
    distm <- daisy(clusterm, metric)
    cat("Done!\n")
    
    cat("Hierarchical clustering... ")
    clust <- hclust(distm, method)
    cat("Done!\n")
    
    cutClusters <- doDynamicTreeCut(clust, maxTreeHeight, deepSplit, minModuleSize)
    names(cutClusters) <- colnames(gTable)
    clinds <- seq_along(unique(cutClusters))
    
    cInfo <- data.table(name = paste0("CMP", seq_along(clinds)),
                        size = sapply(clinds, function(ci) sum(cutClusters == ci)))
    
    gInfo <- groupInfo(fGroups)
    comps <- lapply(clinds, function(ci)
    {
        gNames <- names(cutClusters)[cutClusters == ci]
        return(data.table(group = gNames, ret = gInfo[gNames, "rts"], mz = gInfo[gNames, "mzs"]))
    })
    names(comps) <- cInfo$name
    
    return(componentsIntClust(components = comps, componentInfo = cInfo, clusterm = clusterm, distm = distm,
                              clust = clust, cutClusters = cutClusters,
                              properties = list(metric = metric, method = method, average = average),
                              algorithm = "IntClust"))
}
