#' @include main.R
#' @include compounds.R
#' @include mspeaklists.R
#' @include formulas.R
NULL

#' Compounds list class for MetFrag results.
#'
#' This class is derived from \code{\link{compounds}} and contains additional
#' specific MetFrag data.
#'
#' Objects from this class are generated by
#' \code{\link{generateCompoundsMetfrag}}
#'
#' @slot settings A list with all general configuration settings passed to
#'   MetFrag. Feature specific items (\emph{e.g.} spectra and precursor masses)
#'   are not contained in this list.
#'
#' @param compoundsMF A \code{compoundsMF} object.
#'
#' @templateVar class compoundsMF
#' @template class-hierarchy
#'
#' @seealso \code{\link{compounds}} and \link{compound-generation}
#'
#' @references \insertRef{Ruttkies2016}{patRoon}
#'
#' @export
compoundsMF <- setClass("compoundsMF", slots = c(settings = "list"),
                        contains = "compounds")

setMethod("initialize", "compoundsMF",
          function(.Object, ...) callNextMethod(.Object, algorithm = "metfrag", ...))


#' @describeIn compoundsMF Accessor method for the \code{settings} slot.
#' @aliases settings
#' @export
setMethod("settings", "compoundsMF", function(compoundsMF) compoundsMF@settings)


unifyMFNames <- function(mfr)
{
    unNames <- c(NoExplPeaks = "explainedPeaks",
                 Score = "score",
                 MonoisotopicMass = "neutralMass",
                 SMILES = "SMILES",
                 InChIKey = "InChIKey",
                 InChIKey2 = "InChIKey2",
                 InChIKey1 = "InChIKey1",
                 InChI = "InChi",
                 Identifier = "identifier",
                 PubChemNumberPatents = "numberPatents",
                 fragInfo = "fragInfo", # keep it
                 PubChemNumberPubMedReferences = "pubMedReferences",
                 ChemSpiderNumberPubMedReferences = "pubMedReferences",
                 FragmenterScore = "fragScore",
                 MolecularFormula = "formula",
                 XlogP3 = "XlogP",
                 CHEMSPIDER_XLOGP = "XlogP",
                 TrivialName = "compoundName",
                 CompoundName = "compoundName",
                 IUPACName = "compoundName",
                 CHEMSPIDER_ALOGP = "AlogP",
                 ChemSpiderNumberExternalReferences = "extReferenceCount",
                 ChemSpiderDataSourceCount = "dataSourceCount",
                 ChemSpiderReferenceCount = "referenceCount",
                 ChemSpiderRSCCount = "RSCCount",
                 OfflineMetFusionScore = "metFusionScore",
                 OfflineIndividualMoNAScore = "individualMoNAScore",
                 SmartsSubstructureInclusionScore = "smartsInclusionScore",
                 SmartsSubstructureExclusionScore = "smartsExclusionScore",
                 SuspectListScore = "suspectListScore",
                 RetentionTimeScore = "retentionTimeScore",

                 # Dashboard variables
                 CASRN_DTXSID = "CASRN",
                 CPDAT_COUNT = "CPDATCount",
                 ECOTOX = "ECOTOX",
                 NORMANSUSDAT = "NORMANSUSDAT",
                 TOXCAST_PERCENT_ACTIVE = "TOXCASTActive",
                 NUMBER_OF_PUBMED_ARTICLES = "pubMedReferences",
                 MASSBANKEU = "MASSBANKEU",
                 #MONOISOTOPIC_MASS_DTXCID = "neutralMass",
                 QC_LEVEL = "QCLevel",
                 DATA_SOURCES = "dataSources",
                 PUBCHEM_DATA_SOURCES = "pubChemDataSources",
                 TOX21SL = "TOX21SL",
                 "EXPOCAST_MEDIAN_EXPOSURE_PREDICTION_MG/KG-BW/DAY" = "EXPOCASTPredExpo",
                 TOXCAST = "TOXCAST"
                 )

    unNames <- unNames[names(unNames) %in% names(mfr)] # filter out missing
    setnames(mfr, names(unNames), unNames)

    return(mfr[, unNames, with = FALSE]) # filter out any other columns
}

# MetFragCL gives bracketed fragment formulas including charge and weird (de)protonation adducts
# For comparison with other results these should be converted to a simple formula format
cleanFragFormulas <- function(forms)
{
    forms <- gsub("\\[|\\]", "", forms) # remove brackets
    forms <- gsub("[-\\+]$", "", forms) # remove trailing charge

    # add single counts to hydrogen adducts without count (e.g. -H becomes -1H)
    forms <- gsub("([-\\+])H", "\\11H", forms)

    adducts <- regmatches(forms, gregexpr("([-\\+][0-9]+)H", forms)) # get "-1H", "+2H" etc

    # Get 'regular' part of formula and update H count
    baseForms <- gsub("^([[:alnum:]]+)[-|\\+].*", "\\1", forms)

    return(sapply(seq_along(forms), function(fi)
    {
        addHCount <- sum(as.integer(gsub("H", "", adducts[[fi]])))
        flist <- splitFormulaToList(baseForms[[fi]])

        if (addHCount != 0)
        {
            if (!"H" %in% names(flist))
            {
                flist <- c(flist, addHCount)
                names(flist)[length(flist)] <- "H"
            }
            else
                flist[["H"]] <- flist[["H"]] + addHCount
        }
        return(formulaListToString(flist))
    }))
}

getMFFragmentInfo <- function(spec, mfResult, adduct)
{
    if (mfResult$NoExplPeaks == 0 || mfResult$FormulasOfExplPeaks == "NA")
        return(data.table(mz = numeric(0), formula = character(0), score = numeric(0), PLIndex = numeric(0)))

    # format of FormulasOfExplPeaks: list of strings with mz1:formula1;mz2:formula2;...
    fi <- unlist(strsplit(mfResult$FormulasOfExplPeaks, "[;:]")) # split into list with subsequent m/z / formula pairs

    ret <- data.table(mz = as.numeric(fi[c(TRUE, FALSE)]),
                      formula = cleanFragFormulas(fi[c(FALSE, TRUE)]))
    if (!is.null(mfResult[["FragmenterScore_Values"]]))
        ret[, score := as.numeric(unlist(strsplit(mfResult$FragmenterScore_Values, ";")))]
    ionform <- calculateIonFormula(mfResult$MolecularFormula, adduct)
    ret[, neutral_loss := sapply(formula, subtractFormula, formula1 = ionform)]
    ret[, PLIndex := sapply(mz, function(omz) which.min(abs(omz - spec$mz)))]
    ret[, intensity := spec$intensity[PLIndex]]
    setcolorder(ret, c("mz", "formula", "neutral_loss", "intensity"))

    return(ret)
}

initMetFragCLCommand <- function(mfSettings, spec, mfBin, logFile)
{
    paramFile <- tempfile("parameters", fileext = ".txt")
    paramCon <- file(paramFile, "w")

    writeParam <- function(param, val) cat(sprintf("%s = %s\n", param, paste0(as.character(val), collapse = ",")), file = paramCon)

    for (param in names(mfSettings))
        writeParam(param, mfSettings[[param]])

    outFile <- tempfile("results", fileext = ".csv")
    writeParam("MetFragCandidateWriter", "CSV")
    writeParam("SampleName", basename(tools::file_path_sans_ext(outFile)))
    writeParam("ResultsPath", dirname(outFile))

    specFile <- tempfile("spectrum", fileext = ".txt")
    write.table(spec[, c("mz", "intensity")], specFile, sep = "\t", row.names = FALSE, col.names = FALSE)
    writeParam("PeakListPath", specFile)

    close(paramCon)

    return(list(command = "java", args = c("-jar", mfBin, paramFile), stderrFile = logFile, outFile = outFile))
}

generateMetFragRunData <- function(fGroups, MSPeakLists, mfSettings, topMost, identifiers, method, addTrivialNames)
{
    gNames <- names(fGroups)
    gTable <- groups(fGroups)
    gInfo <- groupInfo(fGroups)
    anaInfo <- analysisInfo(fGroups)

    ret <- sapply(gNames, function(grp)
    {
        if (!is.null(identifiers) && is.null(identifiers[[grp]]))
            return(NULL)

        spec <- MSPeakLists[[grp]][["MSMS"]]
        if (is.null(spec))
            return(NULL)

        mfSettings$IonizedPrecursorMass <- gInfo[grp, "mzs"]
        mfSettings$ExperimentalRetentionTimeValue <- gInfo[grp, "rts"] / 60

        if (!is.null(identifiers))
            mfSettings$PrecursorCompoundIDs <- identifiers[[grp]]

        hash <- makeHash(method, mfSettings, spec, topMost, if (method == "R") addTrivialNames else FALSE)

        return(list(hash = hash, gName = grp, spec = spec, mfSettings = mfSettings))
    }, simplify = FALSE)

    return(ret[!sapply(ret, is.null)])
}

processMFResults <- function(comptab, spec, adduct, db, topMost, lfile = "")
{
    scRanges <- list()
    
    if (nrow(comptab) > 0)
    {
        compsc <- compoundScorings("metfrag")
        compsc <- compsc[compsc$metfrag %in% names(comptab), ]
        
        if (nrow(compsc) > 0)
        {
            # fix up score and suspect list columns: dash --> 0
            # NOTE: do as.numeric as values with '-' will cause the column to be a character
            comptab[, (compsc$metfrag) := lapply(.SD, function(x) as.numeric(ifelse(x == "-", 0, x))),
                    .SDcols = compsc$metfrag]
            
            scRanges <- setNames(lapply(compsc$metfrag, function(sc) range(comptab[[sc]])),
                                 compsc$name)
        }
        
        if (!is.null(topMost) && nrow(comptab) > topMost)
            comptab <- comptab[seq_len(topMost)]

        # make character: needed for getMFFragmentInfo()
        # note: this column is not present in empty tables so can't do this with colClasses
        if (!is.null(comptab[["FragmenterScore_Values"]]))
            comptab[, FragmenterScore_Values := as.character(FragmenterScore_Values)]

        # fill in fragment info
        # NOTE: double wrap in list to nest table
        if (!is.null(lfile))
            cat(sprintf("\n%s - Done! Processing frags...\n", date()), file = lfile, append = TRUE)
        for (r in seq_len(nrow(comptab)))
            set(comptab, r, "fragInfo", list(list(getMFFragmentInfo(spec, comptab[r], adduct))))
        if (!is.null(lfile))
            cat(sprintf("\n%s - Done!\n", date()), file = lfile, append = TRUE)

        # unify column names & filter unnecessary columns
        comptab <- unifyMFNames(comptab)

        if (!is.null(comptab[["CASRN"]]))
            comptab[, CASRN := sub("CASRN:", "", CASRN, fixed = TRUE)] # remove "CASRN" prefix

        comptab[, database := db]
    }

    return(list(comptab = comptab, scRanges = scRanges))
}

#' @details \code{generateCompoundsMetfrag} uses the \pkg{metfRag} package for
#'   compound identification (see \url{http://c-ruttkies.github.io/MetFrag/}).
#'   Several online compound databases such as
#'   \href{https://pubchem.ncbi.nlm.nih.gov/}{PubChem} and
#'   \href{http://www.chemspider.com/}{ChemSpider} may be chosen for retrieval
#'   of candidate structures. In addition, many options exist to score and
#'   filter resulting data, and it is highly suggested to optimize these to
#'   improve results. While MS/MS data is not mandatory, it will usually greatly
#'   improve candidate scoring. The \command{MetFrag} options \code{PeakList},
#'   \code{IonizedPrecursorMass} and \code{ExperimentalRetentionTimeValue} (in
#'   minutes) fields are automatically set from feature data.
#'
#' @param method Which method should be used for MetFrag execution: \code{"CL"}
#'   for \command{MetFragCL} and \code{"R"} for \command{MetFragR}. The former
#'   might be faster.
#' @param timeout Maximum time (in seconds) before a metFrag query for a feature
#'   group is stopped. Also see \code{timeoutRetries} argument.
#' @param timeoutRetries Maximum number of retries after reaching a timeout
#'   before completely skipping the metFrag query for a feature group. Also see
#'   \code{timeout} argument.
#' @param dbRelMzDev Relative mass deviation (in ppm) for database search. Sets
#'   the \option{DatabaseSearchRelativeMassDeviation} option.
#' @param fragRelMzDev Relative mass deviation (in ppm) for fragment matching.
#'   Sets the \option{FragmentPeakMatchRelativeMassDeviation} option.
#' @param fragAbsMzDev Absolute mass deviation (in Da) for fragment matching.
#'   Sets the \option{FragmentPeakMatchAbsoluteMassDeviation} option.
#' @param database Compound database to use. Valid values are: \code{"pubchem"},
#'   \code{"chemspider"}, \code{"toxcast"}, \code{"kegg"}, \code{"sdf"},
#'   \code{"psv"} and \code{"csv"}. See section below for more information. Sets
#'   the \code{MetFragDatabaseType} option.
#' @param extendedPubChem If \code{database="pubchem"}: whether to use the
#'   \emph{extended} database that includes information for compound scoring
#'   (\emph{i.e.} number of patents/PubMed references). Note that downloading
#'   candidates from this database might take extra time. Valid values are:
#'   \code{FALSE} (never use it), \code{TRUE} (always use it) or \code{"auto"}
#'   (default, use if specified scorings demand it).
#' @param chemSpiderToken A character string with the
#'   \href{http://www.chemspider.com/AboutServices.aspx}{ChemSpider security
#'   token} that should be set when the ChemSpider database is used. Sets the
#'   \option{ChemSpiderToken} option.
#' @param scoreTypes A character vector defining the scoring types. See the
#'   \verb{Scorings} section below for more information. Note that both generic
#'   and \command{MetFrag} specific names are accepted (\emph{i.e.} \code{name}
#'   and \code{metfrag} columns returned by \code{compoundScorings}). When a
#'   local database is used, the name should match what is given there
#'   (\code{e.g} column names when \code{database=csv}). Note that MetFrag may
#'   still report other scoring data, however, these are not used for ranking.
#'   Sets the \option{MetFragScoreTypes} option.
#' @param scoreWeights Numeric vector containing weights of the used scoring
#'   types. Order is the same as set in \code{scoreTypes}. Values are recycled
#'   if necessary. Sets the \option{MetFragScoreWeights} option.
#' @param preProcessingFilters,postProcessingFilters A character vector defining
#'   pre/post filters applied before/after fragmentation and scoring
#'   (\emph{e.g.} \code{"UnconnectedCompoundFilter"}, \code{"IsotopeFilter"},
#'   \code{"ElementExclusionFilter"}). Some methods require further options to
#'   be set. For all filters and more information refer to the \verb{Candidate
#'   Filters} section on the
#'   \href{http://c-ruttkies.github.io/MetFrag/projects/metfragr/}{MetFragR
#'   homepage}. Sets the \option{MetFragPreProcessingCandidateFilter} and
#'   \code{MetFragPostProcessingCandidateFilter} options.
#' @param maxCandidatesToStop If more than this number of candidate structures
#'   are found then processing will be aborted and no results this feature group
#'   will be reported. Low values increase the chance of missing data, whereas
#'   too high values will use too much computer resources and signficantly
#'   slowdown the process. Sets the \option{MaxCandidateLimitToStop} option.
#' @param addTrivialNames If \code{TRUE} and the PubChem database is used then
#'   trivial names will be added after compound search.
#' @param identifiers A \code{list} containing for each feature group a
#'   character vector with database identifiers that should be used to find
#'   candidates for a feature group (the list should be named by feature group
#'   names). If \code{NULL} all relevant candidates will be retrieved from the
#'   specified database. An example usage scenario is to obtain the list of
#'   candidate identifiers from a \code{\link{compounds}} object obtained with
#'   \code{\link{generateCompoundsSirius}} using the \code{\link{identifiers}}
#'   method. This way, only those candidates will be searched by MetFrag that
#'   were generated by SIRIUS+CSI:FingerID. Sets the
#'   \option{PrecursorCompoundIDs} option.
#'
#' @return \code{generateCompoundsMetFrag} returns a \code{\link{compoundsMF}}
#'   object.
#'
#' @section Usage of MetFrag databases: When \code{database="chemspider"}
#'   setting the \code{chemSpiderToken} argument is mandatory.
#'
#'   When a local database is set (\emph{i.e.} \code{sdf}, \code{psv},
#'   \code{csv}, \code{toxcast}) the file location of the database should be set
#'   in the \code{LocalDatabasePath} value via the \code{extraOpts} argument or
#'   using the \code{patRoon.path.MetFragCompTox} option (only when
#'   \code{database="comptox"}).
#'
#'   Examples: \verb{options(patRoon.path.MetFragCompTox =
#'   "C:/DSSTox_01May18_Full_SelectMetaDataPlus.csv")} \verb{extraOpts =
#'   list(LocalDatabasePath = \"C:/myDB.csv\")}.
#'
#'   Note that for \code{database="comptox"} currently only scorings from the
#'   \file{SelectMetaData} and \file{SelectMetaDataPlus} files are supported.
#'   These files can be obtained from
#'   \url{https://epa.figshare.com/articles/CompTox_Chemicals_Dashboard_Metadata_Files_for_Integration_with_MetFrag/7525199}.
#'   Note that only recent \command{MetFrag} versions (>= \samp{2.4.5}) support
#'   these libraries.
#'
#' @references \insertRef{Ruttkies2016}{patRoon}
#'
#' @rdname compound-generation
#' @export
generateCompoundsMetfrag <- function(fGroups, MSPeakLists, method = "CL", logPath = file.path("log", "metfrag"),
                                     timeout = 300, timeoutRetries = 2, errorRetries = 2, topMost = 100,
                                     dbRelMzDev = 5, fragRelMzDev = 5, fragAbsMzDev = 0.002, adduct,
                                     database = "pubchem", extendedPubChem = "auto", chemSpiderToken = "",
                                     scoreTypes = compoundScorings("metfrag", database, onlyDefault = TRUE)$name,
                                     scoreWeights = 1.0,
                                     preProcessingFilters = c("UnconnectedCompoundFilter", "IsotopeFilter"),
                                     postProcessingFilters = c("InChIKeyFilter"),
                                     maxCandidatesToStop = 2500, addTrivialNames = TRUE,
                                     identifiers = NULL, extraOpts = NULL,
                                     maxProcAmount = getOption("patRoon.maxProcAmount"))
{
    # UNDONE: does addTrivialNames actually work?

    if (method == "R")
        checkPackage("metfRag", "c-ruttkies/MetFragR")

    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertChoice(method, c("CL", "R"), add = ac)
    assertMultiProcArgs(logPath, maxProcAmount, add = ac)
    aapply(checkmate::assertNumber, . ~ timeout + dbRelMzDev + fragRelMzDev + fragAbsMzDev,
           lower = 0, finite = TRUE, fixed = list(add = ac))
    aapply(checkmate::assertCount, . ~ timeoutRetries + errorRetries, fixed = list(add = ac))
    aapply(checkmate::assertCount, . ~ topMost + maxCandidatesToStop, positive = TRUE, fixed = list(add = ac))
    aapply(checkmate::assertFlag, . ~ addTrivialNames, fixed = list(add = ac))
    checkmate::assertString(chemSpiderToken, add = ac)
    checkmate::assertChoice(database, c("pubchem", "chemspider", "kegg", "sdf", "psv", "csv", "comptox"), add = ac)
    checkmate::assert(checkmate::checkFlag(extendedPubChem),
                      checkmate::checkChoice(extendedPubChem, "auto"),
                      .var.name = "extendedPubChem")
    aapply(checkmate::assertCharacter, . ~ scoreTypes + preProcessingFilters + postProcessingFilters,
           any.missing = FALSE, fixed = list(add = ac))
    checkmate::assertNumeric(scoreWeights, lower = 0, finite = TRUE, any.missing = FALSE, min.len = 1, add = ac)
    aapply(checkmate::assertList, . ~ identifiers + extraOpts, any.missing = FALSE,
           names = "unique", null.ok = TRUE, fixed = list(add = ac))

    compsScores <- compoundScorings("metfrag", database)
    isLocalDB <- database %in% c("sdf", "psv", "csv", "comptox")
    allScoringNames <- union(compsScores$name, compsScores$metfrag)        
    # allow freely definable scorings from local databases
    if (!isLocalDB)
        checkmate::assertSubset(scoreTypes, allScoringNames, add = ac)

    checkmate::reportAssertions(ac)

    adduct <- checkAndToAdduct(adduct)
    
    extDB <- if (!is.null(extraOpts)) extraOpts[["LocalDatabasePath"]] else NULL
    if (database == "comptox" && is.null(extDB))
    {
        extDB <- getOption("patRoon.path.MetFragCompTox", NULL)
        if (!is.null(extDB))
            extraOpts <- modifyList(if (!is.null(extraOpts)) extraOpts else list(), list(LocalDatabasePath = extDB))
    }
        
    if (isLocalDB && (is.null(extDB) || !file.exists(extDB)))
    {
        ex <- "as part of the extraOpts argument, e.g. extraOpts = list(LocalDatabasePath = \"C:/DSSTox_01May18_Full_SelectMetaDataPlus.csv\")"
        if (database == "comptox")
            stop(paste("No (valid) external database file set. This should be either set as an option, e.g.",
                       "options(patRoon.path.MetFragCompTox = \"C:/DSSTox_01May18_Full_SelectMetaDataPlus.csv\") or", ex))
        
        stop(paste("No external database file set. This should be set", ex))
    }
    
    anaInfo <- analysisInfo(fGroups)
    ftind <- groupFeatIndex(fGroups)
    gTable <- groups(fGroups)
    gNames <- names(fGroups)
    gCount <- length(fGroups)
    gInfo <- groupInfo(fGroups)
    pLists <- peakLists(MSPeakLists)

    if (!is.logical(extendedPubChem) && database == "pubchem")
    {
        PCScorings <- compoundScorings("metfrag", "pubchem", includeNoDB = FALSE)
        extendedPubChem <- any(scoreTypes %in% union(PCScorings$name, PCScorings$metfrag))
    }

    # convert to metfrag naming scheme
    database <- switch(database,
                       pubchem = "PubChem",
                       chemspider = "ChemSpider",
                       kegg = "KEGG",
                       sdf = "LocalSDF",
                       psv = "LocalPSV",
                       csv = "LocalCSV",
                       comptox = "LocalCSV")
    if (database == "PubChem" && extendedPubChem) # can't seem to combine this conditional in above switch...
        database <- "ExtendedPubChem"

    rownames(compsScores) <- compsScores$name
    scoreTypesMF <- setdiff(scoreTypes, c("score", "Score")) # final score is to be determined
    isSimplScore <- scoreTypesMF %in% compsScores$name
    if (any(isSimplScore))
        scoreTypesMF[isSimplScore] <- compsScores[scoreTypesMF[isSimplScore], "metfrag"]

    mfSettings <- list(DatabaseSearchRelativeMassDeviation = dbRelMzDev,
                       FragmentPeakMatchRelativeMassDeviation = fragRelMzDev,
                       FragmentPeakMatchAbsoluteMassDeviation = fragAbsMzDev,
                       PrecursorIonType = as.character(adduct, format = "metfrag"),
                       MetFragDatabaseType = database, MetFragScoreTypes = scoreTypesMF,
                       MetFragScoreWeights = rep(scoreWeights, length.out = length(scoreTypesMF)),
                       MetFragPreProcessingCandidateFilter = preProcessingFilters,
                       MetFragPostProcessingCandidateFilter = postProcessingFilters,
                       MaxCandidateLimitToStop = maxCandidatesToStop)

    if (!is.null(chemSpiderToken) && nzchar(chemSpiderToken))
        mfSettings$ChemSpiderToken <- chemSpiderToken

    if (!is.null(extraOpts))
    {
        # add (or replace) any extra options
        mfSettings <- modifyList(mfSettings, extraOpts)
    }

    cacheDB <- openCacheDBScope()
    setHash <- makeHash(fGroups, pLists, method, mfSettings, topMost, identifiers, addTrivialNames)
    cachedSet <- loadCacheSet("compoundsMetFrag", setHash, cacheDB)
    resultHashes <- vector("character", length(gNames))
    names(resultHashes) <- gNames

    printf("Identifying %d feature groups with MetFrag...\n", gCount)

    runData <- generateMetFragRunData(fGroups, MSPeakLists, mfSettings, topMost, identifiers, method, addTrivialNames)

    cachedResults <- sapply(runData, function(rd)
    {
        resultHashes[rd$gName] <<- rd$hash
        comptab <- NULL
        if (!is.null(cachedSet))
            comptab <- cachedSet[[rd$hash]]
        if (is.null(comptab))
            comptab <- loadCacheData("compoundsMetFrag", rd$hash, cacheDB)
        return(comptab)
    }, simplify = FALSE)
    cachedResults <- cachedResults[!sapply(cachedResults, is.null)]

    runData <- runData[setdiff(names(runData), names(cachedResults))] # remove cached results

    if (length(runData) > 0)
    {
        if (method == "CL")
        {
            if (!is.null(logPath))
                mkdirp(logPath)
            mfBin <- path.expand(getOption("patRoon.path.MetFragCL"))
            if (is.null(mfBin) || !nzchar(mfBin) || !file.exists(mfBin))
                stop("Please set the 'MetFragCL' option with a (correct) path to the metFrag CL jar file. Example: options(patRoon.path.MetFragCL = \"C:/MetFrag2.4.2-CL.jar\")")

            if (!nzchar(Sys.which("java")))
                stop("Please make sure that java is installed and its location is correctly set in PATH.")

            cmdQueue <- lapply(runData, function(rd)
            {
                logf <- if (!is.null(logPath)) file.path(logPath, paste0("mfcl-", rd$gName, ".txt")) else NULL
                return(c(rd[c("hash", "gName", "spec")],
                         initMetFragCLCommand(rd$mfSettings, rd$spec, mfBin, logf)))
            })

            results <- executeMultiProcess(cmdQueue, finishHandler = function(cmd, exitStatus, retries)
            {
                if (!is.null(cmd$stderrFile))
                    cat(sprintf("\n%s - Done with MF! Reading results...\n", date()), file = cmd$stderrFile, append = TRUE)
                comptab <- fread(cmd$outFile, colClasses = c(Identifier = "character"))
                if (!is.null(cmd$stderrFile))
                    cat(sprintf("\n%s - Done! Processing results...\n", date()), file = cmd$stderrFile, append = TRUE)
                procres <- processMFResults(comptab, cmd$spec, adduct, database, topMost, cmd$stderrFile)
                if (!is.null(cmd$stderrFile))
                    cat(sprintf("\n%s - Done! Caching results...\n", date()), file = cmd$stderrFile, append = TRUE)
                saveCacheData("compoundsMetFrag", procres, cmd$hash, cacheDB)
                if (!is.null(cmd$stderrFile))
                    cat(sprintf("\n%s - Done!\n", date()), file = cmd$stderrFile, append = TRUE)

                return(procres)
            }, timeoutHandler = function(cmd, retries)
            {
                if (retries >= timeoutRetries)
                {
                    warning(sprintf("Could not run MetFrag for %s: timeout", cmd$gName))
                    return(FALSE)
                }
                warning(sprintf("Restarting timed out MetFrag command for %s (retry %d/%d)",
                                cmd$gName, retries+1, errorRetries))
                return(TRUE)
            }, errorHandler = function(cmd, exitStatus, retries)
            {
                if (exitStatus <= 6) # some error thrown by MF
                {
                    if (retries >= errorRetries)
                    {
                        warning(sprintf("Could not run MetFrag for %s - exit code: %d", cmd$gName, exitStatus))
                        return(FALSE)
                    }
                    warning(sprintf("Restarting failed MetFrag command for %s - exit: %d (retry %d/%d)",
                                    cmd$gName, exitStatus, retries+1, errorRetries))
                    return(TRUE)
                }

                # some other error (e.g. java not present)
                stop(sprintf("Fatal: Failed to execute MetFragCL for %s - exit code: %d", cmd$gName, exitStatus))
            }, maxProcAmount = maxProcAmount, procTimeout = timeout, delayBetweenProc = 1000)
        }
        else
        {
            prog <- txtProgressBar(0, gCount, style = 3)

            results <- lapply(runData, function(rd)
            {
                rd$mfSettings$PeakList <- as.matrix(rd$spec[, c("mz", "intensity")])
                comptab <- metfRag::run.metfrag(rd$mfSettings)
                jgc() # hopefully reduce some memory usage

                if (nrow(comptab) > 0)
                {
                    if (addTrivialNames && rd$mfSettings$MetFragDatabaseType %in% c("PubChem", "ExtendedPubChem"))
                    {
                        # fetching trivial names may sometimes fail with connection error, just ignore this for now
                        tryCatch(comptab <<- metfRag::add.trivialname.pubchem(comptab), error = function(e) comptab$TrivialName <<- NA)
                    }

                    comptab <- unFactorDF(comptab)
                    comptab <- as.data.table(comptab)

                    procres <- processMFResults(comptab, rd$spec, adduct, database, topMost)

                    # BUG: metfRag seems to give second duplicate results where only NoExplPeaks may differ and have an incorrect value.
                    # for now, just remove all duplicates and re-assign NoExplPeaks
                    procres$comptab <- procres$comptab[!duplicated(identifier)]
                    procres$comptab[, explainedPeaks := sapply(fragInfo, nrow)]
                }

                saveCacheData("compoundsMetFrag", procres, rd$hash, cacheDB)

                setTxtProgressBar(prog, match(rd$gName, gNames))

                return(procres)
            })

            setTxtProgressBar(prog, gCount)
            close(prog)
        }
    }
    else
        results <- list()

    if (length(cachedResults) > 0)
    {
        results <- c(results, cachedResults)
        results <- results[intersect(gNames, names(results))] # re-order
    }

    # prune empty/NULL results
    if (length(results) > 0)
        results <- results[sapply(results, function(r) !is.null(r$comptab) && nrow(r$comptab) > 0, USE.NAMES = FALSE)]

    ngrp <- length(results)
    printf("Loaded %d compounds from %d features (%.2f%%).\n", sum(unlist(lapply(results, function(r) nrow(r$comptab)))),
           ngrp, if (gCount == 0) 0 else ngrp * 100 / gCount)

    if (is.null(cachedSet))
        saveCacheSet("compoundsMetFrag", resultHashes[resultHashes != ""], setHash, cacheDB)

    # convert scoreTypes to generic names
    scoreTypes <- union(scoreTypes, "score") # ensure final score is in and remove duplicates
    isMFScore <- scoreTypes %in% compsScores$metfrag
    if (any(isMFScore))
        scoreTypes[isMFScore] <- compsScores[match(scoreTypes[isMFScore], compsScores$metfrag), "name"]
    
    return(compoundsMF(compounds = lapply(results, "[[", "comptab"), scoreTypes = scoreTypes,
                       scoreRanges = lapply(results, "[[", "scRanges"),
                       settings = mfSettings))
}
